schema {
  query: Query
  subscription: Subscription
}

"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""Defined a Subgraph ID for an object type"""
directive @subgraphId(id: String!) on OBJECT

type Account {
  bApps(first: Int = 100, orderBy: BApp_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: BApp_filter): [BApp!]!
  clusters(first: Int = 100, orderBy: Cluster_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Cluster_filter): [Cluster!]
  delegators(first: Int = 100, orderBy: Delegation_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Delegation_filter): [Delegation!]!
  deposits(first: Int = 100, orderBy: StrategyUserBalance_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: StrategyUserBalance_filter): [StrategyUserBalance!]!
  feeRecipient: Bytes!
  id: Bytes!
  metadataURI: String
  nonce: BigInt!
  operators(first: Int = 100, orderBy: Operator_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Operator_filter): [Operator!]
  receivers(first: Int = 100, orderBy: Delegation_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Delegation_filter): [Delegation!]!
  strategies(first: Int = 100, orderBy: Strategy_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Strategy_filter): [Strategy!]!
  totalDelegatedPercentage: BigInt!
  validatorCount: BigInt!
  validators(first: Int = 100, orderBy: Validator_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Validator_filter): [Validator!]
}

type AccountMetadataURIUpdated {
  account: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  metadataURI: String!
  transactionHash: Bytes!
}

input AccountMetadataURIUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  and: [AccountMetadataURIUpdated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  metadataURI: String
  metadataURI_contains: String
  metadataURI_contains_nocase: String
  metadataURI_ends_with: String
  metadataURI_ends_with_nocase: String
  metadataURI_gt: String
  metadataURI_gte: String
  metadataURI_in: [String!]
  metadataURI_lt: String
  metadataURI_lte: String
  metadataURI_not: String
  metadataURI_not_contains: String
  metadataURI_not_contains_nocase: String
  metadataURI_not_ends_with: String
  metadataURI_not_ends_with_nocase: String
  metadataURI_not_in: [String!]
  metadataURI_not_starts_with: String
  metadataURI_not_starts_with_nocase: String
  metadataURI_starts_with: String
  metadataURI_starts_with_nocase: String
  or: [AccountMetadataURIUpdated_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum AccountMetadataURIUpdated_orderBy {
  account
  blockNumber
  blockTimestamp
  id
  metadataURI
  transactionHash
}

input Account_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Account_filter]
  bApps_: BApp_filter
  clusters_: Cluster_filter
  delegators_: Delegation_filter
  deposits_: StrategyUserBalance_filter
  feeRecipient: Bytes
  feeRecipient_contains: Bytes
  feeRecipient_gt: Bytes
  feeRecipient_gte: Bytes
  feeRecipient_in: [Bytes!]
  feeRecipient_lt: Bytes
  feeRecipient_lte: Bytes
  feeRecipient_not: Bytes
  feeRecipient_not_contains: Bytes
  feeRecipient_not_in: [Bytes!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  metadataURI: String
  metadataURI_contains: String
  metadataURI_contains_nocase: String
  metadataURI_ends_with: String
  metadataURI_ends_with_nocase: String
  metadataURI_gt: String
  metadataURI_gte: String
  metadataURI_in: [String!]
  metadataURI_lt: String
  metadataURI_lte: String
  metadataURI_not: String
  metadataURI_not_contains: String
  metadataURI_not_contains_nocase: String
  metadataURI_not_ends_with: String
  metadataURI_not_ends_with_nocase: String
  metadataURI_not_in: [String!]
  metadataURI_not_starts_with: String
  metadataURI_not_starts_with_nocase: String
  metadataURI_starts_with: String
  metadataURI_starts_with_nocase: String
  nonce: BigInt
  nonce_gt: BigInt
  nonce_gte: BigInt
  nonce_in: [BigInt!]
  nonce_lt: BigInt
  nonce_lte: BigInt
  nonce_not: BigInt
  nonce_not_in: [BigInt!]
  operators_: Operator_filter
  or: [Account_filter]
  receivers_: Delegation_filter
  strategies_: Strategy_filter
  totalDelegatedPercentage: BigInt
  totalDelegatedPercentage_gt: BigInt
  totalDelegatedPercentage_gte: BigInt
  totalDelegatedPercentage_in: [BigInt!]
  totalDelegatedPercentage_lt: BigInt
  totalDelegatedPercentage_lte: BigInt
  totalDelegatedPercentage_not: BigInt
  totalDelegatedPercentage_not_in: [BigInt!]
  validatorCount: BigInt
  validatorCount_gt: BigInt
  validatorCount_gte: BigInt
  validatorCount_in: [BigInt!]
  validatorCount_lt: BigInt
  validatorCount_lte: BigInt
  validatorCount_not: BigInt
  validatorCount_not_in: [BigInt!]
  validators_: Validator_filter
}

enum Account_orderBy {
  bApps
  clusters
  delegators
  deposits
  feeRecipient
  id
  metadataURI
  nonce
  operators
  receivers
  strategies
  totalDelegatedPercentage
  validatorCount
  validators
}

enum Aggregation_interval {
  day
  hour
}

type BApp {
  bAppTokens(first: Int = 100, orderBy: BAppToken_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: BAppToken_filter): [BAppToken!]!
  id: Bytes!
  metadataURI: String
  owner: Account!
  strategies(first: Int = 100, orderBy: StrategyBAppOptIn_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: StrategyBAppOptIn_filter): [StrategyBAppOptIn!]!
}

type BAppConstants {
  _maxFeeIncrement: BigInt!
  id: Bytes!
  totalAccounts: BigInt!
  totalBApps: BigInt!
  totalStrategies: BigInt!
}

input BAppConstants_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  _maxFeeIncrement: BigInt
  _maxFeeIncrement_gt: BigInt
  _maxFeeIncrement_gte: BigInt
  _maxFeeIncrement_in: [BigInt!]
  _maxFeeIncrement_lt: BigInt
  _maxFeeIncrement_lte: BigInt
  _maxFeeIncrement_not: BigInt
  _maxFeeIncrement_not_in: [BigInt!]
  and: [BAppConstants_filter]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [BAppConstants_filter]
  totalAccounts: BigInt
  totalAccounts_gt: BigInt
  totalAccounts_gte: BigInt
  totalAccounts_in: [BigInt!]
  totalAccounts_lt: BigInt
  totalAccounts_lte: BigInt
  totalAccounts_not: BigInt
  totalAccounts_not_in: [BigInt!]
  totalBApps: BigInt
  totalBApps_gt: BigInt
  totalBApps_gte: BigInt
  totalBApps_in: [BigInt!]
  totalBApps_lt: BigInt
  totalBApps_lte: BigInt
  totalBApps_not: BigInt
  totalBApps_not_in: [BigInt!]
  totalStrategies: BigInt
  totalStrategies_gt: BigInt
  totalStrategies_gte: BigInt
  totalStrategies_in: [BigInt!]
  totalStrategies_lt: BigInt
  totalStrategies_lte: BigInt
  totalStrategies_not: BigInt
  totalStrategies_not_in: [BigInt!]
}

enum BAppConstants_orderBy {
  _maxFeeIncrement
  id
  totalAccounts
  totalBApps
  totalStrategies
}

type BAppMetadataURIUpdated {
  bAppAddress: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  metadataURI: String!
  transactionHash: Bytes!
}

input BAppMetadataURIUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [BAppMetadataURIUpdated_filter]
  bAppAddress: Bytes
  bAppAddress_contains: Bytes
  bAppAddress_gt: Bytes
  bAppAddress_gte: Bytes
  bAppAddress_in: [Bytes!]
  bAppAddress_lt: Bytes
  bAppAddress_lte: Bytes
  bAppAddress_not: Bytes
  bAppAddress_not_contains: Bytes
  bAppAddress_not_in: [Bytes!]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  metadataURI: String
  metadataURI_contains: String
  metadataURI_contains_nocase: String
  metadataURI_ends_with: String
  metadataURI_ends_with_nocase: String
  metadataURI_gt: String
  metadataURI_gte: String
  metadataURI_in: [String!]
  metadataURI_lt: String
  metadataURI_lte: String
  metadataURI_not: String
  metadataURI_not_contains: String
  metadataURI_not_contains_nocase: String
  metadataURI_not_ends_with: String
  metadataURI_not_ends_with_nocase: String
  metadataURI_not_in: [String!]
  metadataURI_not_starts_with: String
  metadataURI_not_starts_with_nocase: String
  metadataURI_starts_with: String
  metadataURI_starts_with_nocase: String
  or: [BAppMetadataURIUpdated_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum BAppMetadataURIUpdated_orderBy {
  bAppAddress
  blockNumber
  blockTimestamp
  id
  metadataURI
  transactionHash
}

type BAppOptedInByStrategy {
  bApp: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  data: Bytes!
  id: Bytes!
  obligationPercentages: [BigInt!]!
  strategyId: BigInt!
  tokens: [Bytes!]!
  transactionHash: Bytes!
}

input BAppOptedInByStrategy_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [BAppOptedInByStrategy_filter]
  bApp: Bytes
  bApp_contains: Bytes
  bApp_gt: Bytes
  bApp_gte: Bytes
  bApp_in: [Bytes!]
  bApp_lt: Bytes
  bApp_lte: Bytes
  bApp_not: Bytes
  bApp_not_contains: Bytes
  bApp_not_in: [Bytes!]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  data: Bytes
  data_contains: Bytes
  data_gt: Bytes
  data_gte: Bytes
  data_in: [Bytes!]
  data_lt: Bytes
  data_lte: Bytes
  data_not: Bytes
  data_not_contains: Bytes
  data_not_in: [Bytes!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  obligationPercentages: [BigInt!]
  obligationPercentages_contains: [BigInt!]
  obligationPercentages_contains_nocase: [BigInt!]
  obligationPercentages_not: [BigInt!]
  obligationPercentages_not_contains: [BigInt!]
  obligationPercentages_not_contains_nocase: [BigInt!]
  or: [BAppOptedInByStrategy_filter]
  strategyId: BigInt
  strategyId_gt: BigInt
  strategyId_gte: BigInt
  strategyId_in: [BigInt!]
  strategyId_lt: BigInt
  strategyId_lte: BigInt
  strategyId_not: BigInt
  strategyId_not_in: [BigInt!]
  tokens: [Bytes!]
  tokens_contains: [Bytes!]
  tokens_contains_nocase: [Bytes!]
  tokens_not: [Bytes!]
  tokens_not_contains: [Bytes!]
  tokens_not_contains_nocase: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum BAppOptedInByStrategy_orderBy {
  bApp
  blockNumber
  blockTimestamp
  data
  id
  obligationPercentages
  strategyId
  tokens
  transactionHash
}

type BAppRegistered {
  bAppAddress: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  metadataURI: String!
  owner: Bytes!
  sharedRiskLevel: [BigInt!]!
  tokens: [Bytes!]!
  transactionHash: Bytes!
}

input BAppRegistered_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [BAppRegistered_filter]
  bAppAddress: Bytes
  bAppAddress_contains: Bytes
  bAppAddress_gt: Bytes
  bAppAddress_gte: Bytes
  bAppAddress_in: [Bytes!]
  bAppAddress_lt: Bytes
  bAppAddress_lte: Bytes
  bAppAddress_not: Bytes
  bAppAddress_not_contains: Bytes
  bAppAddress_not_in: [Bytes!]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  metadataURI: String
  metadataURI_contains: String
  metadataURI_contains_nocase: String
  metadataURI_ends_with: String
  metadataURI_ends_with_nocase: String
  metadataURI_gt: String
  metadataURI_gte: String
  metadataURI_in: [String!]
  metadataURI_lt: String
  metadataURI_lte: String
  metadataURI_not: String
  metadataURI_not_contains: String
  metadataURI_not_contains_nocase: String
  metadataURI_not_ends_with: String
  metadataURI_not_ends_with_nocase: String
  metadataURI_not_in: [String!]
  metadataURI_not_starts_with: String
  metadataURI_not_starts_with_nocase: String
  metadataURI_starts_with: String
  metadataURI_starts_with_nocase: String
  or: [BAppRegistered_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  sharedRiskLevel: [BigInt!]
  sharedRiskLevel_contains: [BigInt!]
  sharedRiskLevel_contains_nocase: [BigInt!]
  sharedRiskLevel_not: [BigInt!]
  sharedRiskLevel_not_contains: [BigInt!]
  sharedRiskLevel_not_contains_nocase: [BigInt!]
  tokens: [Bytes!]
  tokens_contains: [Bytes!]
  tokens_contains_nocase: [Bytes!]
  tokens_not: [Bytes!]
  tokens_not_contains: [Bytes!]
  tokens_not_contains_nocase: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum BAppRegistered_orderBy {
  bAppAddress
  blockNumber
  blockTimestamp
  id
  metadataURI
  owner
  sharedRiskLevel
  tokens
  transactionHash
}

type BAppToken {
  bApp: BApp!
  id: String!
  sharedRiskLevel: BigInt!
  token: Bytes!
  totalObligatedBalance: BigInt!
}

input BAppToken_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [BAppToken_filter]
  bApp: String
  bApp_: BApp_filter
  bApp_contains: String
  bApp_contains_nocase: String
  bApp_ends_with: String
  bApp_ends_with_nocase: String
  bApp_gt: String
  bApp_gte: String
  bApp_in: [String!]
  bApp_lt: String
  bApp_lte: String
  bApp_not: String
  bApp_not_contains: String
  bApp_not_contains_nocase: String
  bApp_not_ends_with: String
  bApp_not_ends_with_nocase: String
  bApp_not_in: [String!]
  bApp_not_starts_with: String
  bApp_not_starts_with_nocase: String
  bApp_starts_with: String
  bApp_starts_with_nocase: String
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [BAppToken_filter]
  sharedRiskLevel: BigInt
  sharedRiskLevel_gt: BigInt
  sharedRiskLevel_gte: BigInt
  sharedRiskLevel_in: [BigInt!]
  sharedRiskLevel_lt: BigInt
  sharedRiskLevel_lte: BigInt
  sharedRiskLevel_not: BigInt
  sharedRiskLevel_not_in: [BigInt!]
  token: Bytes
  token_contains: Bytes
  token_gt: Bytes
  token_gte: Bytes
  token_in: [Bytes!]
  token_lt: Bytes
  token_lte: Bytes
  token_not: Bytes
  token_not_contains: Bytes
  token_not_in: [Bytes!]
  totalObligatedBalance: BigInt
  totalObligatedBalance_gt: BigInt
  totalObligatedBalance_gte: BigInt
  totalObligatedBalance_in: [BigInt!]
  totalObligatedBalance_lt: BigInt
  totalObligatedBalance_lte: BigInt
  totalObligatedBalance_not: BigInt
  totalObligatedBalance_not_in: [BigInt!]
}

enum BAppToken_orderBy {
  bApp
  bApp__id
  bApp__metadataURI
  id
  sharedRiskLevel
  token
  totalObligatedBalance
}

type BAppTokensCreated {
  bAppAddress: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  sharedRiskLevels: [BigInt!]!
  tokens: [Bytes!]!
  transactionHash: Bytes!
}

input BAppTokensCreated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [BAppTokensCreated_filter]
  bAppAddress: Bytes
  bAppAddress_contains: Bytes
  bAppAddress_gt: Bytes
  bAppAddress_gte: Bytes
  bAppAddress_in: [Bytes!]
  bAppAddress_lt: Bytes
  bAppAddress_lte: Bytes
  bAppAddress_not: Bytes
  bAppAddress_not_contains: Bytes
  bAppAddress_not_in: [Bytes!]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [BAppTokensCreated_filter]
  sharedRiskLevels: [BigInt!]
  sharedRiskLevels_contains: [BigInt!]
  sharedRiskLevels_contains_nocase: [BigInt!]
  sharedRiskLevels_not: [BigInt!]
  sharedRiskLevels_not_contains: [BigInt!]
  sharedRiskLevels_not_contains_nocase: [BigInt!]
  tokens: [Bytes!]
  tokens_contains: [Bytes!]
  tokens_contains_nocase: [Bytes!]
  tokens_not: [Bytes!]
  tokens_not_contains: [Bytes!]
  tokens_not_contains_nocase: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum BAppTokensCreated_orderBy {
  bAppAddress
  blockNumber
  blockTimestamp
  id
  sharedRiskLevels
  tokens
  transactionHash
}

type BAppTokensUpdated {
  bAppAddress: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  sharedRiskLevels: [BigInt!]!
  tokens: [Bytes!]!
  transactionHash: Bytes!
}

input BAppTokensUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [BAppTokensUpdated_filter]
  bAppAddress: Bytes
  bAppAddress_contains: Bytes
  bAppAddress_gt: Bytes
  bAppAddress_gte: Bytes
  bAppAddress_in: [Bytes!]
  bAppAddress_lt: Bytes
  bAppAddress_lte: Bytes
  bAppAddress_not: Bytes
  bAppAddress_not_contains: Bytes
  bAppAddress_not_in: [Bytes!]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [BAppTokensUpdated_filter]
  sharedRiskLevels: [BigInt!]
  sharedRiskLevels_contains: [BigInt!]
  sharedRiskLevels_contains_nocase: [BigInt!]
  sharedRiskLevels_not: [BigInt!]
  sharedRiskLevels_not_contains: [BigInt!]
  sharedRiskLevels_not_contains_nocase: [BigInt!]
  tokens: [Bytes!]
  tokens_contains: [Bytes!]
  tokens_contains_nocase: [Bytes!]
  tokens_not: [Bytes!]
  tokens_not_contains: [Bytes!]
  tokens_not_contains_nocase: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum BAppTokensUpdated_orderBy {
  bAppAddress
  blockNumber
  blockTimestamp
  id
  sharedRiskLevels
  tokens
  transactionHash
}

input BApp_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [BApp_filter]
  bAppTokens_: BAppToken_filter
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  metadataURI: String
  metadataURI_contains: String
  metadataURI_contains_nocase: String
  metadataURI_ends_with: String
  metadataURI_ends_with_nocase: String
  metadataURI_gt: String
  metadataURI_gte: String
  metadataURI_in: [String!]
  metadataURI_lt: String
  metadataURI_lte: String
  metadataURI_not: String
  metadataURI_not_contains: String
  metadataURI_not_contains_nocase: String
  metadataURI_not_ends_with: String
  metadataURI_not_ends_with_nocase: String
  metadataURI_not_in: [String!]
  metadataURI_not_starts_with: String
  metadataURI_not_starts_with_nocase: String
  metadataURI_starts_with: String
  metadataURI_starts_with_nocase: String
  or: [BApp_filter]
  owner: String
  owner_: Account_filter
  owner_contains: String
  owner_contains_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_gt: String
  owner_gte: String
  owner_in: [String!]
  owner_lt: String
  owner_lte: String
  owner_not: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_not_in: [String!]
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  strategies_: StrategyBAppOptIn_filter
}

enum BApp_orderBy {
  bAppTokens
  id
  metadataURI
  owner
  owner__feeRecipient
  owner__id
  owner__metadataURI
  owner__nonce
  owner__totalDelegatedPercentage
  owner__validatorCount
  strategies
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type Cluster {
  active: Boolean!
  balance: BigInt!
  id: String!
  index: BigInt!
  lastUpdateBlockNumber: BigInt!
  lastUpdateBlockTimestamp: BigInt!
  lastUpdateTransactionHash: Bytes!
  networkFeeIndex: BigInt!
  operatorIds: [BigInt!]!
  owner: Account!
  validatorCount: BigInt!
  validators(first: Int = 100, orderBy: Validator_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Validator_filter): [Validator!]
}

type ClusterDeposited {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  cluster_active: Boolean!
  cluster_balance: BigInt!
  cluster_index: BigInt!
  cluster_networkFeeIndex: BigInt!
  cluster_validatorCount: BigInt!
  id: String!
  operatorIds: [BigInt!]!
  owner: Bytes!
  transactionHash: Bytes!
  value: BigInt!
}

input ClusterDeposited_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ClusterDeposited_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  cluster_active: Boolean
  cluster_active_in: [Boolean!]
  cluster_active_not: Boolean
  cluster_active_not_in: [Boolean!]
  cluster_balance: BigInt
  cluster_balance_gt: BigInt
  cluster_balance_gte: BigInt
  cluster_balance_in: [BigInt!]
  cluster_balance_lt: BigInt
  cluster_balance_lte: BigInt
  cluster_balance_not: BigInt
  cluster_balance_not_in: [BigInt!]
  cluster_index: BigInt
  cluster_index_gt: BigInt
  cluster_index_gte: BigInt
  cluster_index_in: [BigInt!]
  cluster_index_lt: BigInt
  cluster_index_lte: BigInt
  cluster_index_not: BigInt
  cluster_index_not_in: [BigInt!]
  cluster_networkFeeIndex: BigInt
  cluster_networkFeeIndex_gt: BigInt
  cluster_networkFeeIndex_gte: BigInt
  cluster_networkFeeIndex_in: [BigInt!]
  cluster_networkFeeIndex_lt: BigInt
  cluster_networkFeeIndex_lte: BigInt
  cluster_networkFeeIndex_not: BigInt
  cluster_networkFeeIndex_not_in: [BigInt!]
  cluster_validatorCount: BigInt
  cluster_validatorCount_gt: BigInt
  cluster_validatorCount_gte: BigInt
  cluster_validatorCount_in: [BigInt!]
  cluster_validatorCount_lt: BigInt
  cluster_validatorCount_lte: BigInt
  cluster_validatorCount_not: BigInt
  cluster_validatorCount_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorIds: [BigInt!]
  operatorIds_contains: [BigInt!]
  operatorIds_contains_nocase: [BigInt!]
  operatorIds_not: [BigInt!]
  operatorIds_not_contains: [BigInt!]
  operatorIds_not_contains_nocase: [BigInt!]
  or: [ClusterDeposited_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum ClusterDeposited_orderBy {
  blockNumber
  blockTimestamp
  cluster_active
  cluster_balance
  cluster_index
  cluster_networkFeeIndex
  cluster_validatorCount
  id
  operatorIds
  owner
  transactionHash
  value
}

type ClusterLiquidated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  cluster_active: Boolean!
  cluster_balance: BigInt!
  cluster_index: BigInt!
  cluster_networkFeeIndex: BigInt!
  cluster_validatorCount: BigInt!
  id: String!
  operatorIds: [BigInt!]!
  owner: Bytes!
  transactionHash: Bytes!
}

input ClusterLiquidated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ClusterLiquidated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  cluster_active: Boolean
  cluster_active_in: [Boolean!]
  cluster_active_not: Boolean
  cluster_active_not_in: [Boolean!]
  cluster_balance: BigInt
  cluster_balance_gt: BigInt
  cluster_balance_gte: BigInt
  cluster_balance_in: [BigInt!]
  cluster_balance_lt: BigInt
  cluster_balance_lte: BigInt
  cluster_balance_not: BigInt
  cluster_balance_not_in: [BigInt!]
  cluster_index: BigInt
  cluster_index_gt: BigInt
  cluster_index_gte: BigInt
  cluster_index_in: [BigInt!]
  cluster_index_lt: BigInt
  cluster_index_lte: BigInt
  cluster_index_not: BigInt
  cluster_index_not_in: [BigInt!]
  cluster_networkFeeIndex: BigInt
  cluster_networkFeeIndex_gt: BigInt
  cluster_networkFeeIndex_gte: BigInt
  cluster_networkFeeIndex_in: [BigInt!]
  cluster_networkFeeIndex_lt: BigInt
  cluster_networkFeeIndex_lte: BigInt
  cluster_networkFeeIndex_not: BigInt
  cluster_networkFeeIndex_not_in: [BigInt!]
  cluster_validatorCount: BigInt
  cluster_validatorCount_gt: BigInt
  cluster_validatorCount_gte: BigInt
  cluster_validatorCount_in: [BigInt!]
  cluster_validatorCount_lt: BigInt
  cluster_validatorCount_lte: BigInt
  cluster_validatorCount_not: BigInt
  cluster_validatorCount_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorIds: [BigInt!]
  operatorIds_contains: [BigInt!]
  operatorIds_contains_nocase: [BigInt!]
  operatorIds_not: [BigInt!]
  operatorIds_not_contains: [BigInt!]
  operatorIds_not_contains_nocase: [BigInt!]
  or: [ClusterLiquidated_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum ClusterLiquidated_orderBy {
  blockNumber
  blockTimestamp
  cluster_active
  cluster_balance
  cluster_index
  cluster_networkFeeIndex
  cluster_validatorCount
  id
  operatorIds
  owner
  transactionHash
}

type ClusterReactivated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  cluster_active: Boolean!
  cluster_balance: BigInt!
  cluster_index: BigInt!
  cluster_networkFeeIndex: BigInt!
  cluster_validatorCount: BigInt!
  id: String!
  operatorIds: [BigInt!]!
  owner: Bytes!
  transactionHash: Bytes!
}

input ClusterReactivated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ClusterReactivated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  cluster_active: Boolean
  cluster_active_in: [Boolean!]
  cluster_active_not: Boolean
  cluster_active_not_in: [Boolean!]
  cluster_balance: BigInt
  cluster_balance_gt: BigInt
  cluster_balance_gte: BigInt
  cluster_balance_in: [BigInt!]
  cluster_balance_lt: BigInt
  cluster_balance_lte: BigInt
  cluster_balance_not: BigInt
  cluster_balance_not_in: [BigInt!]
  cluster_index: BigInt
  cluster_index_gt: BigInt
  cluster_index_gte: BigInt
  cluster_index_in: [BigInt!]
  cluster_index_lt: BigInt
  cluster_index_lte: BigInt
  cluster_index_not: BigInt
  cluster_index_not_in: [BigInt!]
  cluster_networkFeeIndex: BigInt
  cluster_networkFeeIndex_gt: BigInt
  cluster_networkFeeIndex_gte: BigInt
  cluster_networkFeeIndex_in: [BigInt!]
  cluster_networkFeeIndex_lt: BigInt
  cluster_networkFeeIndex_lte: BigInt
  cluster_networkFeeIndex_not: BigInt
  cluster_networkFeeIndex_not_in: [BigInt!]
  cluster_validatorCount: BigInt
  cluster_validatorCount_gt: BigInt
  cluster_validatorCount_gte: BigInt
  cluster_validatorCount_in: [BigInt!]
  cluster_validatorCount_lt: BigInt
  cluster_validatorCount_lte: BigInt
  cluster_validatorCount_not: BigInt
  cluster_validatorCount_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorIds: [BigInt!]
  operatorIds_contains: [BigInt!]
  operatorIds_contains_nocase: [BigInt!]
  operatorIds_not: [BigInt!]
  operatorIds_not_contains: [BigInt!]
  operatorIds_not_contains_nocase: [BigInt!]
  or: [ClusterReactivated_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum ClusterReactivated_orderBy {
  blockNumber
  blockTimestamp
  cluster_active
  cluster_balance
  cluster_index
  cluster_networkFeeIndex
  cluster_validatorCount
  id
  operatorIds
  owner
  transactionHash
}

type ClusterWithdrawn {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  cluster_active: Boolean!
  cluster_balance: BigInt!
  cluster_index: BigInt!
  cluster_networkFeeIndex: BigInt!
  cluster_validatorCount: BigInt!
  id: String!
  operatorIds: [BigInt!]!
  owner: Bytes!
  transactionHash: Bytes!
  value: BigInt!
}

input ClusterWithdrawn_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ClusterWithdrawn_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  cluster_active: Boolean
  cluster_active_in: [Boolean!]
  cluster_active_not: Boolean
  cluster_active_not_in: [Boolean!]
  cluster_balance: BigInt
  cluster_balance_gt: BigInt
  cluster_balance_gte: BigInt
  cluster_balance_in: [BigInt!]
  cluster_balance_lt: BigInt
  cluster_balance_lte: BigInt
  cluster_balance_not: BigInt
  cluster_balance_not_in: [BigInt!]
  cluster_index: BigInt
  cluster_index_gt: BigInt
  cluster_index_gte: BigInt
  cluster_index_in: [BigInt!]
  cluster_index_lt: BigInt
  cluster_index_lte: BigInt
  cluster_index_not: BigInt
  cluster_index_not_in: [BigInt!]
  cluster_networkFeeIndex: BigInt
  cluster_networkFeeIndex_gt: BigInt
  cluster_networkFeeIndex_gte: BigInt
  cluster_networkFeeIndex_in: [BigInt!]
  cluster_networkFeeIndex_lt: BigInt
  cluster_networkFeeIndex_lte: BigInt
  cluster_networkFeeIndex_not: BigInt
  cluster_networkFeeIndex_not_in: [BigInt!]
  cluster_validatorCount: BigInt
  cluster_validatorCount_gt: BigInt
  cluster_validatorCount_gte: BigInt
  cluster_validatorCount_in: [BigInt!]
  cluster_validatorCount_lt: BigInt
  cluster_validatorCount_lte: BigInt
  cluster_validatorCount_not: BigInt
  cluster_validatorCount_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorIds: [BigInt!]
  operatorIds_contains: [BigInt!]
  operatorIds_contains_nocase: [BigInt!]
  operatorIds_not: [BigInt!]
  operatorIds_not_contains: [BigInt!]
  operatorIds_not_contains_nocase: [BigInt!]
  or: [ClusterWithdrawn_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum ClusterWithdrawn_orderBy {
  blockNumber
  blockTimestamp
  cluster_active
  cluster_balance
  cluster_index
  cluster_networkFeeIndex
  cluster_validatorCount
  id
  operatorIds
  owner
  transactionHash
  value
}

input Cluster_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  active: Boolean
  active_in: [Boolean!]
  active_not: Boolean
  active_not_in: [Boolean!]
  and: [Cluster_filter]
  balance: BigInt
  balance_gt: BigInt
  balance_gte: BigInt
  balance_in: [BigInt!]
  balance_lt: BigInt
  balance_lte: BigInt
  balance_not: BigInt
  balance_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  index: BigInt
  index_gt: BigInt
  index_gte: BigInt
  index_in: [BigInt!]
  index_lt: BigInt
  index_lte: BigInt
  index_not: BigInt
  index_not_in: [BigInt!]
  lastUpdateBlockNumber: BigInt
  lastUpdateBlockNumber_gt: BigInt
  lastUpdateBlockNumber_gte: BigInt
  lastUpdateBlockNumber_in: [BigInt!]
  lastUpdateBlockNumber_lt: BigInt
  lastUpdateBlockNumber_lte: BigInt
  lastUpdateBlockNumber_not: BigInt
  lastUpdateBlockNumber_not_in: [BigInt!]
  lastUpdateBlockTimestamp: BigInt
  lastUpdateBlockTimestamp_gt: BigInt
  lastUpdateBlockTimestamp_gte: BigInt
  lastUpdateBlockTimestamp_in: [BigInt!]
  lastUpdateBlockTimestamp_lt: BigInt
  lastUpdateBlockTimestamp_lte: BigInt
  lastUpdateBlockTimestamp_not: BigInt
  lastUpdateBlockTimestamp_not_in: [BigInt!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_gt: Bytes
  lastUpdateTransactionHash_gte: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_lt: Bytes
  lastUpdateTransactionHash_lte: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  lastUpdateTransactionHash_not_in: [Bytes!]
  networkFeeIndex: BigInt
  networkFeeIndex_gt: BigInt
  networkFeeIndex_gte: BigInt
  networkFeeIndex_in: [BigInt!]
  networkFeeIndex_lt: BigInt
  networkFeeIndex_lte: BigInt
  networkFeeIndex_not: BigInt
  networkFeeIndex_not_in: [BigInt!]
  operatorIds: [BigInt!]
  operatorIds_contains: [BigInt!]
  operatorIds_contains_nocase: [BigInt!]
  operatorIds_not: [BigInt!]
  operatorIds_not_contains: [BigInt!]
  operatorIds_not_contains_nocase: [BigInt!]
  or: [Cluster_filter]
  owner: String
  owner_: Account_filter
  owner_contains: String
  owner_contains_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_gt: String
  owner_gte: String
  owner_in: [String!]
  owner_lt: String
  owner_lte: String
  owner_not: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_not_in: [String!]
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  validatorCount: BigInt
  validatorCount_gt: BigInt
  validatorCount_gte: BigInt
  validatorCount_in: [BigInt!]
  validatorCount_lt: BigInt
  validatorCount_lte: BigInt
  validatorCount_not: BigInt
  validatorCount_not_in: [BigInt!]
  validators_: Validator_filter
}

enum Cluster_orderBy {
  active
  balance
  id
  index
  lastUpdateBlockNumber
  lastUpdateBlockTimestamp
  lastUpdateTransactionHash
  networkFeeIndex
  operatorIds
  owner
  owner__feeRecipient
  owner__id
  owner__metadataURI
  owner__nonce
  owner__totalDelegatedPercentage
  owner__validatorCount
  validatorCount
  validators
}

enum DAOUpdateTypes {
  DECLARE_OPERATOR_FEE_PERIOD
  EXECUTE_OPERATOR_FEE_PERIOD
  INITIALIZATION
  LIQUIDATION_THRESHOLD
  MIN_LIQUIDATION_COLLATERAL
  NETWORK_FEE
  OPERATOR_ADDED
  OPERATOR_FEE_INCREASE_LIMIT
  OPERATOR_MAX_FEE
  OPERATOR_REMOVED
  VALIDATOR_ADDED
  VALIDATOR_REMOVED
}

type DAOValues {
  declareOperatorFeePeriod: BigInt!
  executeOperatorFeePeriod: BigInt!
  id: Bytes!
  lastUpdateBlockNumber: BigInt!
  lastUpdateBlockTimestamp: BigInt!
  lastUpdateTransactionHash: Bytes!
  liquidationThreshold: BigInt!
  minimumLiquidationCollateral: BigInt!
  networkFee: BigInt!
  networkFeeIndex: BigInt!
  networkFeeIndexBlockNumber: BigInt!
  operatorFeeIncreaseLimit: BigInt!
  operatorMaximumFee: BigInt!
  operatorsAdded: BigInt!
  operatorsRemoved: BigInt!
  totalAccounts: BigInt!
  totalOperators: BigInt!
  totalValidators: BigInt!
  updateType: DAOUpdateTypes!
  validatorsAdded: BigInt!
  validatorsPerOperatorLimit: BigInt!
  validatorsRemoved: BigInt!
}

input DAOValues_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [DAOValues_filter]
  declareOperatorFeePeriod: BigInt
  declareOperatorFeePeriod_gt: BigInt
  declareOperatorFeePeriod_gte: BigInt
  declareOperatorFeePeriod_in: [BigInt!]
  declareOperatorFeePeriod_lt: BigInt
  declareOperatorFeePeriod_lte: BigInt
  declareOperatorFeePeriod_not: BigInt
  declareOperatorFeePeriod_not_in: [BigInt!]
  executeOperatorFeePeriod: BigInt
  executeOperatorFeePeriod_gt: BigInt
  executeOperatorFeePeriod_gte: BigInt
  executeOperatorFeePeriod_in: [BigInt!]
  executeOperatorFeePeriod_lt: BigInt
  executeOperatorFeePeriod_lte: BigInt
  executeOperatorFeePeriod_not: BigInt
  executeOperatorFeePeriod_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  lastUpdateBlockNumber: BigInt
  lastUpdateBlockNumber_gt: BigInt
  lastUpdateBlockNumber_gte: BigInt
  lastUpdateBlockNumber_in: [BigInt!]
  lastUpdateBlockNumber_lt: BigInt
  lastUpdateBlockNumber_lte: BigInt
  lastUpdateBlockNumber_not: BigInt
  lastUpdateBlockNumber_not_in: [BigInt!]
  lastUpdateBlockTimestamp: BigInt
  lastUpdateBlockTimestamp_gt: BigInt
  lastUpdateBlockTimestamp_gte: BigInt
  lastUpdateBlockTimestamp_in: [BigInt!]
  lastUpdateBlockTimestamp_lt: BigInt
  lastUpdateBlockTimestamp_lte: BigInt
  lastUpdateBlockTimestamp_not: BigInt
  lastUpdateBlockTimestamp_not_in: [BigInt!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_gt: Bytes
  lastUpdateTransactionHash_gte: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_lt: Bytes
  lastUpdateTransactionHash_lte: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  lastUpdateTransactionHash_not_in: [Bytes!]
  liquidationThreshold: BigInt
  liquidationThreshold_gt: BigInt
  liquidationThreshold_gte: BigInt
  liquidationThreshold_in: [BigInt!]
  liquidationThreshold_lt: BigInt
  liquidationThreshold_lte: BigInt
  liquidationThreshold_not: BigInt
  liquidationThreshold_not_in: [BigInt!]
  minimumLiquidationCollateral: BigInt
  minimumLiquidationCollateral_gt: BigInt
  minimumLiquidationCollateral_gte: BigInt
  minimumLiquidationCollateral_in: [BigInt!]
  minimumLiquidationCollateral_lt: BigInt
  minimumLiquidationCollateral_lte: BigInt
  minimumLiquidationCollateral_not: BigInt
  minimumLiquidationCollateral_not_in: [BigInt!]
  networkFee: BigInt
  networkFeeIndex: BigInt
  networkFeeIndexBlockNumber: BigInt
  networkFeeIndexBlockNumber_gt: BigInt
  networkFeeIndexBlockNumber_gte: BigInt
  networkFeeIndexBlockNumber_in: [BigInt!]
  networkFeeIndexBlockNumber_lt: BigInt
  networkFeeIndexBlockNumber_lte: BigInt
  networkFeeIndexBlockNumber_not: BigInt
  networkFeeIndexBlockNumber_not_in: [BigInt!]
  networkFeeIndex_gt: BigInt
  networkFeeIndex_gte: BigInt
  networkFeeIndex_in: [BigInt!]
  networkFeeIndex_lt: BigInt
  networkFeeIndex_lte: BigInt
  networkFeeIndex_not: BigInt
  networkFeeIndex_not_in: [BigInt!]
  networkFee_gt: BigInt
  networkFee_gte: BigInt
  networkFee_in: [BigInt!]
  networkFee_lt: BigInt
  networkFee_lte: BigInt
  networkFee_not: BigInt
  networkFee_not_in: [BigInt!]
  operatorFeeIncreaseLimit: BigInt
  operatorFeeIncreaseLimit_gt: BigInt
  operatorFeeIncreaseLimit_gte: BigInt
  operatorFeeIncreaseLimit_in: [BigInt!]
  operatorFeeIncreaseLimit_lt: BigInt
  operatorFeeIncreaseLimit_lte: BigInt
  operatorFeeIncreaseLimit_not: BigInt
  operatorFeeIncreaseLimit_not_in: [BigInt!]
  operatorMaximumFee: BigInt
  operatorMaximumFee_gt: BigInt
  operatorMaximumFee_gte: BigInt
  operatorMaximumFee_in: [BigInt!]
  operatorMaximumFee_lt: BigInt
  operatorMaximumFee_lte: BigInt
  operatorMaximumFee_not: BigInt
  operatorMaximumFee_not_in: [BigInt!]
  operatorsAdded: BigInt
  operatorsAdded_gt: BigInt
  operatorsAdded_gte: BigInt
  operatorsAdded_in: [BigInt!]
  operatorsAdded_lt: BigInt
  operatorsAdded_lte: BigInt
  operatorsAdded_not: BigInt
  operatorsAdded_not_in: [BigInt!]
  operatorsRemoved: BigInt
  operatorsRemoved_gt: BigInt
  operatorsRemoved_gte: BigInt
  operatorsRemoved_in: [BigInt!]
  operatorsRemoved_lt: BigInt
  operatorsRemoved_lte: BigInt
  operatorsRemoved_not: BigInt
  operatorsRemoved_not_in: [BigInt!]
  or: [DAOValues_filter]
  totalAccounts: BigInt
  totalAccounts_gt: BigInt
  totalAccounts_gte: BigInt
  totalAccounts_in: [BigInt!]
  totalAccounts_lt: BigInt
  totalAccounts_lte: BigInt
  totalAccounts_not: BigInt
  totalAccounts_not_in: [BigInt!]
  totalOperators: BigInt
  totalOperators_gt: BigInt
  totalOperators_gte: BigInt
  totalOperators_in: [BigInt!]
  totalOperators_lt: BigInt
  totalOperators_lte: BigInt
  totalOperators_not: BigInt
  totalOperators_not_in: [BigInt!]
  totalValidators: BigInt
  totalValidators_gt: BigInt
  totalValidators_gte: BigInt
  totalValidators_in: [BigInt!]
  totalValidators_lt: BigInt
  totalValidators_lte: BigInt
  totalValidators_not: BigInt
  totalValidators_not_in: [BigInt!]
  updateType: DAOUpdateTypes
  updateType_in: [DAOUpdateTypes!]
  updateType_not: DAOUpdateTypes
  updateType_not_in: [DAOUpdateTypes!]
  validatorsAdded: BigInt
  validatorsAdded_gt: BigInt
  validatorsAdded_gte: BigInt
  validatorsAdded_in: [BigInt!]
  validatorsAdded_lt: BigInt
  validatorsAdded_lte: BigInt
  validatorsAdded_not: BigInt
  validatorsAdded_not_in: [BigInt!]
  validatorsPerOperatorLimit: BigInt
  validatorsPerOperatorLimit_gt: BigInt
  validatorsPerOperatorLimit_gte: BigInt
  validatorsPerOperatorLimit_in: [BigInt!]
  validatorsPerOperatorLimit_lt: BigInt
  validatorsPerOperatorLimit_lte: BigInt
  validatorsPerOperatorLimit_not: BigInt
  validatorsPerOperatorLimit_not_in: [BigInt!]
  validatorsRemoved: BigInt
  validatorsRemoved_gt: BigInt
  validatorsRemoved_gte: BigInt
  validatorsRemoved_in: [BigInt!]
  validatorsRemoved_lt: BigInt
  validatorsRemoved_lte: BigInt
  validatorsRemoved_not: BigInt
  validatorsRemoved_not_in: [BigInt!]
}

enum DAOValues_orderBy {
  declareOperatorFeePeriod
  executeOperatorFeePeriod
  id
  lastUpdateBlockNumber
  lastUpdateBlockTimestamp
  lastUpdateTransactionHash
  liquidationThreshold
  minimumLiquidationCollateral
  networkFee
  networkFeeIndex
  networkFeeIndexBlockNumber
  operatorFeeIncreaseLimit
  operatorMaximumFee
  operatorsAdded
  operatorsRemoved
  totalAccounts
  totalOperators
  totalValidators
  updateType
  validatorsAdded
  validatorsPerOperatorLimit
  validatorsRemoved
}

type DeclareOperatorFeePeriodUpdated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  transactionHash: Bytes!
  value: BigInt!
}

input DeclareOperatorFeePeriodUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [DeclareOperatorFeePeriodUpdated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [DeclareOperatorFeePeriodUpdated_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum DeclareOperatorFeePeriodUpdated_orderBy {
  blockNumber
  blockTimestamp
  id
  transactionHash
  value
}

type Delegation {
  delegator: Account!
  id: String!
  percentage: BigInt!
  receiver: Account!
}

type DelegationCreated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  delegator: Bytes!
  id: Bytes!
  percentage: BigInt!
  receiver: Bytes!
  transactionHash: Bytes!
}

input DelegationCreated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [DelegationCreated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  delegator: Bytes
  delegator_contains: Bytes
  delegator_gt: Bytes
  delegator_gte: Bytes
  delegator_in: [Bytes!]
  delegator_lt: Bytes
  delegator_lte: Bytes
  delegator_not: Bytes
  delegator_not_contains: Bytes
  delegator_not_in: [Bytes!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [DelegationCreated_filter]
  percentage: BigInt
  percentage_gt: BigInt
  percentage_gte: BigInt
  percentage_in: [BigInt!]
  percentage_lt: BigInt
  percentage_lte: BigInt
  percentage_not: BigInt
  percentage_not_in: [BigInt!]
  receiver: Bytes
  receiver_contains: Bytes
  receiver_gt: Bytes
  receiver_gte: Bytes
  receiver_in: [Bytes!]
  receiver_lt: Bytes
  receiver_lte: Bytes
  receiver_not: Bytes
  receiver_not_contains: Bytes
  receiver_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum DelegationCreated_orderBy {
  blockNumber
  blockTimestamp
  delegator
  id
  percentage
  receiver
  transactionHash
}

type DelegationRemoved {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  delegator: Bytes!
  id: Bytes!
  receiver: Bytes!
  transactionHash: Bytes!
}

input DelegationRemoved_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [DelegationRemoved_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  delegator: Bytes
  delegator_contains: Bytes
  delegator_gt: Bytes
  delegator_gte: Bytes
  delegator_in: [Bytes!]
  delegator_lt: Bytes
  delegator_lte: Bytes
  delegator_not: Bytes
  delegator_not_contains: Bytes
  delegator_not_in: [Bytes!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [DelegationRemoved_filter]
  receiver: Bytes
  receiver_contains: Bytes
  receiver_gt: Bytes
  receiver_gte: Bytes
  receiver_in: [Bytes!]
  receiver_lt: Bytes
  receiver_lte: Bytes
  receiver_not: Bytes
  receiver_not_contains: Bytes
  receiver_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum DelegationRemoved_orderBy {
  blockNumber
  blockTimestamp
  delegator
  id
  receiver
  transactionHash
}

type DelegationUpdated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  delegator: Bytes!
  id: Bytes!
  percentage: BigInt!
  receiver: Bytes!
  transactionHash: Bytes!
}

input DelegationUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [DelegationUpdated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  delegator: Bytes
  delegator_contains: Bytes
  delegator_gt: Bytes
  delegator_gte: Bytes
  delegator_in: [Bytes!]
  delegator_lt: Bytes
  delegator_lte: Bytes
  delegator_not: Bytes
  delegator_not_contains: Bytes
  delegator_not_in: [Bytes!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [DelegationUpdated_filter]
  percentage: BigInt
  percentage_gt: BigInt
  percentage_gte: BigInt
  percentage_in: [BigInt!]
  percentage_lt: BigInt
  percentage_lte: BigInt
  percentage_not: BigInt
  percentage_not_in: [BigInt!]
  receiver: Bytes
  receiver_contains: Bytes
  receiver_gt: Bytes
  receiver_gte: Bytes
  receiver_in: [Bytes!]
  receiver_lt: Bytes
  receiver_lte: Bytes
  receiver_not: Bytes
  receiver_not_contains: Bytes
  receiver_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum DelegationUpdated_orderBy {
  blockNumber
  blockTimestamp
  delegator
  id
  percentage
  receiver
  transactionHash
}

input Delegation_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Delegation_filter]
  delegator: String
  delegator_: Account_filter
  delegator_contains: String
  delegator_contains_nocase: String
  delegator_ends_with: String
  delegator_ends_with_nocase: String
  delegator_gt: String
  delegator_gte: String
  delegator_in: [String!]
  delegator_lt: String
  delegator_lte: String
  delegator_not: String
  delegator_not_contains: String
  delegator_not_contains_nocase: String
  delegator_not_ends_with: String
  delegator_not_ends_with_nocase: String
  delegator_not_in: [String!]
  delegator_not_starts_with: String
  delegator_not_starts_with_nocase: String
  delegator_starts_with: String
  delegator_starts_with_nocase: String
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [Delegation_filter]
  percentage: BigInt
  percentage_gt: BigInt
  percentage_gte: BigInt
  percentage_in: [BigInt!]
  percentage_lt: BigInt
  percentage_lte: BigInt
  percentage_not: BigInt
  percentage_not_in: [BigInt!]
  receiver: String
  receiver_: Account_filter
  receiver_contains: String
  receiver_contains_nocase: String
  receiver_ends_with: String
  receiver_ends_with_nocase: String
  receiver_gt: String
  receiver_gte: String
  receiver_in: [String!]
  receiver_lt: String
  receiver_lte: String
  receiver_not: String
  receiver_not_contains: String
  receiver_not_contains_nocase: String
  receiver_not_ends_with: String
  receiver_not_ends_with_nocase: String
  receiver_not_in: [String!]
  receiver_not_starts_with: String
  receiver_not_starts_with_nocase: String
  receiver_starts_with: String
  receiver_starts_with_nocase: String
}

enum Delegation_orderBy {
  delegator
  delegator__feeRecipient
  delegator__id
  delegator__metadataURI
  delegator__nonce
  delegator__totalDelegatedPercentage
  delegator__validatorCount
  id
  percentage
  receiver
  receiver__feeRecipient
  receiver__id
  receiver__metadataURI
  receiver__nonce
  receiver__totalDelegatedPercentage
  receiver__validatorCount
}

type ExecuteOperatorFeePeriodUpdated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  transactionHash: Bytes!
  value: BigInt!
}

input ExecuteOperatorFeePeriodUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ExecuteOperatorFeePeriodUpdated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [ExecuteOperatorFeePeriodUpdated_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum ExecuteOperatorFeePeriodUpdated_orderBy {
  blockNumber
  blockTimestamp
  id
  transactionHash
  value
}

type FeeRecipientAddressUpdated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  owner: Bytes!
  recipientAddress: Bytes!
  transactionHash: Bytes!
}

input FeeRecipientAddressUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [FeeRecipientAddressUpdated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [FeeRecipientAddressUpdated_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  recipientAddress: Bytes
  recipientAddress_contains: Bytes
  recipientAddress_gt: Bytes
  recipientAddress_gte: Bytes
  recipientAddress_in: [Bytes!]
  recipientAddress_lt: Bytes
  recipientAddress_lte: Bytes
  recipientAddress_not: Bytes
  recipientAddress_not_contains: Bytes
  recipientAddress_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum FeeRecipientAddressUpdated_orderBy {
  blockNumber
  blockTimestamp
  id
  owner
  recipientAddress
  transactionHash
}

type Initialized {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  transactionHash: Bytes!
  version: BigInt!
}

input Initialized_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Initialized_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [Initialized_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  version: BigInt
  version_gt: BigInt
  version_gte: BigInt
  version_in: [BigInt!]
  version_lt: BigInt
  version_lte: BigInt
  version_not: BigInt
  version_not_in: [BigInt!]
}

enum Initialized_orderBy {
  blockNumber
  blockTimestamp
  id
  transactionHash
  version
}

"""
8 bytes signed integer

"""
scalar Int8

type LiquidationThresholdPeriodUpdated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  transactionHash: Bytes!
  value: BigInt!
}

input LiquidationThresholdPeriodUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [LiquidationThresholdPeriodUpdated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [LiquidationThresholdPeriodUpdated_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum LiquidationThresholdPeriodUpdated_orderBy {
  blockNumber
  blockTimestamp
  id
  transactionHash
  value
}

type MaxFeeIncrementSet {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  newMaxFeeIncrement: BigInt!
  transactionHash: Bytes!
}

input MaxFeeIncrementSet_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [MaxFeeIncrementSet_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  newMaxFeeIncrement: BigInt
  newMaxFeeIncrement_gt: BigInt
  newMaxFeeIncrement_gte: BigInt
  newMaxFeeIncrement_in: [BigInt!]
  newMaxFeeIncrement_lt: BigInt
  newMaxFeeIncrement_lte: BigInt
  newMaxFeeIncrement_not: BigInt
  newMaxFeeIncrement_not_in: [BigInt!]
  or: [MaxFeeIncrementSet_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum MaxFeeIncrementSet_orderBy {
  blockNumber
  blockTimestamp
  id
  newMaxFeeIncrement
  transactionHash
}

type MinimumLiquidationCollateralUpdated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  transactionHash: Bytes!
  value: BigInt!
}

input MinimumLiquidationCollateralUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [MinimumLiquidationCollateralUpdated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [MinimumLiquidationCollateralUpdated_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum MinimumLiquidationCollateralUpdated_orderBy {
  blockNumber
  blockTimestamp
  id
  transactionHash
  value
}

type NetworkEarningsWithdrawn {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  recipient: Bytes!
  transactionHash: Bytes!
  value: BigInt!
}

input NetworkEarningsWithdrawn_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [NetworkEarningsWithdrawn_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [NetworkEarningsWithdrawn_filter]
  recipient: Bytes
  recipient_contains: Bytes
  recipient_gt: Bytes
  recipient_gte: Bytes
  recipient_in: [Bytes!]
  recipient_lt: Bytes
  recipient_lte: Bytes
  recipient_not: Bytes
  recipient_not_contains: Bytes
  recipient_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum NetworkEarningsWithdrawn_orderBy {
  blockNumber
  blockTimestamp
  id
  recipient
  transactionHash
  value
}

type NetworkFeeUpdated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  newFee: BigInt!
  oldFee: BigInt!
  transactionHash: Bytes!
}

input NetworkFeeUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [NetworkFeeUpdated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  newFee: BigInt
  newFee_gt: BigInt
  newFee_gte: BigInt
  newFee_in: [BigInt!]
  newFee_lt: BigInt
  newFee_lte: BigInt
  newFee_not: BigInt
  newFee_not_in: [BigInt!]
  oldFee: BigInt
  oldFee_gt: BigInt
  oldFee_gte: BigInt
  oldFee_in: [BigInt!]
  oldFee_lt: BigInt
  oldFee_lte: BigInt
  oldFee_not: BigInt
  oldFee_not_in: [BigInt!]
  or: [NetworkFeeUpdated_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum NetworkFeeUpdated_orderBy {
  blockNumber
  blockTimestamp
  id
  newFee
  oldFee
  transactionHash
}

type Obligation {
  id: String!
  obligatedBalance: BigInt!
  percentage: BigInt!
  percentageProposed: BigInt!
  percentageProposedTimestamp: BigInt!
  strategyBAppOptIn: StrategyBAppOptIn!
  token: Bytes!
}

type ObligationCreated {
  bApp: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  obligationPercentage: BigInt!
  strategyId: BigInt!
  token: Bytes!
  transactionHash: Bytes!
}

input ObligationCreated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ObligationCreated_filter]
  bApp: Bytes
  bApp_contains: Bytes
  bApp_gt: Bytes
  bApp_gte: Bytes
  bApp_in: [Bytes!]
  bApp_lt: Bytes
  bApp_lte: Bytes
  bApp_not: Bytes
  bApp_not_contains: Bytes
  bApp_not_in: [Bytes!]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  obligationPercentage: BigInt
  obligationPercentage_gt: BigInt
  obligationPercentage_gte: BigInt
  obligationPercentage_in: [BigInt!]
  obligationPercentage_lt: BigInt
  obligationPercentage_lte: BigInt
  obligationPercentage_not: BigInt
  obligationPercentage_not_in: [BigInt!]
  or: [ObligationCreated_filter]
  strategyId: BigInt
  strategyId_gt: BigInt
  strategyId_gte: BigInt
  strategyId_in: [BigInt!]
  strategyId_lt: BigInt
  strategyId_lte: BigInt
  strategyId_not: BigInt
  strategyId_not_in: [BigInt!]
  token: Bytes
  token_contains: Bytes
  token_gt: Bytes
  token_gte: Bytes
  token_in: [Bytes!]
  token_lt: Bytes
  token_lte: Bytes
  token_not: Bytes
  token_not_contains: Bytes
  token_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum ObligationCreated_orderBy {
  bApp
  blockNumber
  blockTimestamp
  id
  obligationPercentage
  strategyId
  token
  transactionHash
}

type ObligationUpdateProposed {
  bApp: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  percentage: BigInt!
  strategyId: BigInt!
  token: Bytes!
  transactionHash: Bytes!
}

input ObligationUpdateProposed_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ObligationUpdateProposed_filter]
  bApp: Bytes
  bApp_contains: Bytes
  bApp_gt: Bytes
  bApp_gte: Bytes
  bApp_in: [Bytes!]
  bApp_lt: Bytes
  bApp_lte: Bytes
  bApp_not: Bytes
  bApp_not_contains: Bytes
  bApp_not_in: [Bytes!]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [ObligationUpdateProposed_filter]
  percentage: BigInt
  percentage_gt: BigInt
  percentage_gte: BigInt
  percentage_in: [BigInt!]
  percentage_lt: BigInt
  percentage_lte: BigInt
  percentage_not: BigInt
  percentage_not_in: [BigInt!]
  strategyId: BigInt
  strategyId_gt: BigInt
  strategyId_gte: BigInt
  strategyId_in: [BigInt!]
  strategyId_lt: BigInt
  strategyId_lte: BigInt
  strategyId_not: BigInt
  strategyId_not_in: [BigInt!]
  token: Bytes
  token_contains: Bytes
  token_gt: Bytes
  token_gte: Bytes
  token_in: [Bytes!]
  token_lt: Bytes
  token_lte: Bytes
  token_not: Bytes
  token_not_contains: Bytes
  token_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum ObligationUpdateProposed_orderBy {
  bApp
  blockNumber
  blockTimestamp
  id
  percentage
  strategyId
  token
  transactionHash
}

type ObligationUpdated {
  bApp: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  isFast: Boolean!
  percentage: BigInt!
  strategyId: BigInt!
  token: Bytes!
  transactionHash: Bytes!
}

input ObligationUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ObligationUpdated_filter]
  bApp: Bytes
  bApp_contains: Bytes
  bApp_gt: Bytes
  bApp_gte: Bytes
  bApp_in: [Bytes!]
  bApp_lt: Bytes
  bApp_lte: Bytes
  bApp_not: Bytes
  bApp_not_contains: Bytes
  bApp_not_in: [Bytes!]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  isFast: Boolean
  isFast_in: [Boolean!]
  isFast_not: Boolean
  isFast_not_in: [Boolean!]
  or: [ObligationUpdated_filter]
  percentage: BigInt
  percentage_gt: BigInt
  percentage_gte: BigInt
  percentage_in: [BigInt!]
  percentage_lt: BigInt
  percentage_lte: BigInt
  percentage_not: BigInt
  percentage_not_in: [BigInt!]
  strategyId: BigInt
  strategyId_gt: BigInt
  strategyId_gte: BigInt
  strategyId_in: [BigInt!]
  strategyId_lt: BigInt
  strategyId_lte: BigInt
  strategyId_not: BigInt
  strategyId_not_in: [BigInt!]
  token: Bytes
  token_contains: Bytes
  token_gt: Bytes
  token_gte: Bytes
  token_in: [Bytes!]
  token_lt: Bytes
  token_lte: Bytes
  token_not: Bytes
  token_not_contains: Bytes
  token_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum ObligationUpdated_orderBy {
  bApp
  blockNumber
  blockTimestamp
  id
  isFast
  percentage
  strategyId
  token
  transactionHash
}

input Obligation_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Obligation_filter]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  obligatedBalance: BigInt
  obligatedBalance_gt: BigInt
  obligatedBalance_gte: BigInt
  obligatedBalance_in: [BigInt!]
  obligatedBalance_lt: BigInt
  obligatedBalance_lte: BigInt
  obligatedBalance_not: BigInt
  obligatedBalance_not_in: [BigInt!]
  or: [Obligation_filter]
  percentage: BigInt
  percentageProposed: BigInt
  percentageProposedTimestamp: BigInt
  percentageProposedTimestamp_gt: BigInt
  percentageProposedTimestamp_gte: BigInt
  percentageProposedTimestamp_in: [BigInt!]
  percentageProposedTimestamp_lt: BigInt
  percentageProposedTimestamp_lte: BigInt
  percentageProposedTimestamp_not: BigInt
  percentageProposedTimestamp_not_in: [BigInt!]
  percentageProposed_gt: BigInt
  percentageProposed_gte: BigInt
  percentageProposed_in: [BigInt!]
  percentageProposed_lt: BigInt
  percentageProposed_lte: BigInt
  percentageProposed_not: BigInt
  percentageProposed_not_in: [BigInt!]
  percentage_gt: BigInt
  percentage_gte: BigInt
  percentage_in: [BigInt!]
  percentage_lt: BigInt
  percentage_lte: BigInt
  percentage_not: BigInt
  percentage_not_in: [BigInt!]
  strategyBAppOptIn: String
  strategyBAppOptIn_: StrategyBAppOptIn_filter
  strategyBAppOptIn_contains: String
  strategyBAppOptIn_contains_nocase: String
  strategyBAppOptIn_ends_with: String
  strategyBAppOptIn_ends_with_nocase: String
  strategyBAppOptIn_gt: String
  strategyBAppOptIn_gte: String
  strategyBAppOptIn_in: [String!]
  strategyBAppOptIn_lt: String
  strategyBAppOptIn_lte: String
  strategyBAppOptIn_not: String
  strategyBAppOptIn_not_contains: String
  strategyBAppOptIn_not_contains_nocase: String
  strategyBAppOptIn_not_ends_with: String
  strategyBAppOptIn_not_ends_with_nocase: String
  strategyBAppOptIn_not_in: [String!]
  strategyBAppOptIn_not_starts_with: String
  strategyBAppOptIn_not_starts_with_nocase: String
  strategyBAppOptIn_starts_with: String
  strategyBAppOptIn_starts_with_nocase: String
  token: Bytes
  token_contains: Bytes
  token_gt: Bytes
  token_gte: Bytes
  token_in: [Bytes!]
  token_lt: Bytes
  token_lte: Bytes
  token_not: Bytes
  token_not_contains: Bytes
  token_not_in: [Bytes!]
}

enum Obligation_orderBy {
  id
  obligatedBalance
  percentage
  percentageProposed
  percentageProposedTimestamp
  strategyBAppOptIn
  strategyBAppOptIn__id
  token
}

type Operator {
  declaredFee: BigInt!
  fee: BigInt!
  feeIndex: BigInt!
  feeIndexBlockNumber: BigInt!
  id: String!
  isPrivate: Boolean!
  lastUpdateBlockNumber: BigInt!
  lastUpdateBlockTimestamp: BigInt!
  lastUpdateTransactionHash: Bytes!
  operatorId: BigInt!
  owner: Account!
  publicKey: Bytes!
  removed: Boolean!
  totalWithdrawn: BigInt!
  validatorCount: BigInt!
  validators(first: Int = 100, orderBy: Validator_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Validator_filter): [Validator!]
  whitelisted(first: Int = 100, orderBy: Account_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Account_filter): [Account!]!
  whitelistedContract: Bytes!
}

type OperatorAdded {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  fee: BigInt!
  id: String!
  operatorId: BigInt!
  owner: Bytes!
  publicKey: Bytes!
  transactionHash: Bytes!
}

input OperatorAdded_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OperatorAdded_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  fee: BigInt
  fee_gt: BigInt
  fee_gte: BigInt
  fee_in: [BigInt!]
  fee_lt: BigInt
  fee_lte: BigInt
  fee_not: BigInt
  fee_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorId: BigInt
  operatorId_gt: BigInt
  operatorId_gte: BigInt
  operatorId_in: [BigInt!]
  operatorId_lt: BigInt
  operatorId_lte: BigInt
  operatorId_not: BigInt
  operatorId_not_in: [BigInt!]
  or: [OperatorAdded_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  publicKey: Bytes
  publicKey_contains: Bytes
  publicKey_gt: Bytes
  publicKey_gte: Bytes
  publicKey_in: [Bytes!]
  publicKey_lt: Bytes
  publicKey_lte: Bytes
  publicKey_not: Bytes
  publicKey_not_contains: Bytes
  publicKey_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum OperatorAdded_orderBy {
  blockNumber
  blockTimestamp
  fee
  id
  operatorId
  owner
  publicKey
  transactionHash
}

type OperatorFeeDeclarationCancelled {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  operatorId: BigInt!
  owner: Bytes!
  transactionHash: Bytes!
}

input OperatorFeeDeclarationCancelled_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OperatorFeeDeclarationCancelled_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorId: BigInt
  operatorId_gt: BigInt
  operatorId_gte: BigInt
  operatorId_in: [BigInt!]
  operatorId_lt: BigInt
  operatorId_lte: BigInt
  operatorId_not: BigInt
  operatorId_not_in: [BigInt!]
  or: [OperatorFeeDeclarationCancelled_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum OperatorFeeDeclarationCancelled_orderBy {
  blockNumber
  blockTimestamp
  id
  operatorId
  owner
  transactionHash
}

type OperatorFeeDeclared {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  fee: BigInt!
  id: String!
  operatorId: BigInt!
  owner: Bytes!
  transactionHash: Bytes!
}

input OperatorFeeDeclared_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OperatorFeeDeclared_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  fee: BigInt
  fee_gt: BigInt
  fee_gte: BigInt
  fee_in: [BigInt!]
  fee_lt: BigInt
  fee_lte: BigInt
  fee_not: BigInt
  fee_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorId: BigInt
  operatorId_gt: BigInt
  operatorId_gte: BigInt
  operatorId_in: [BigInt!]
  operatorId_lt: BigInt
  operatorId_lte: BigInt
  operatorId_not: BigInt
  operatorId_not_in: [BigInt!]
  or: [OperatorFeeDeclared_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum OperatorFeeDeclared_orderBy {
  blockNumber
  blockTimestamp
  fee
  id
  operatorId
  owner
  transactionHash
}

type OperatorFeeExecuted {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  fee: BigInt!
  id: String!
  operatorId: BigInt!
  owner: Bytes!
  transactionHash: Bytes!
}

input OperatorFeeExecuted_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OperatorFeeExecuted_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  fee: BigInt
  fee_gt: BigInt
  fee_gte: BigInt
  fee_in: [BigInt!]
  fee_lt: BigInt
  fee_lte: BigInt
  fee_not: BigInt
  fee_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorId: BigInt
  operatorId_gt: BigInt
  operatorId_gte: BigInt
  operatorId_in: [BigInt!]
  operatorId_lt: BigInt
  operatorId_lte: BigInt
  operatorId_not: BigInt
  operatorId_not_in: [BigInt!]
  or: [OperatorFeeExecuted_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum OperatorFeeExecuted_orderBy {
  blockNumber
  blockTimestamp
  fee
  id
  operatorId
  owner
  transactionHash
}

type OperatorFeeIncreaseLimitUpdated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  transactionHash: Bytes!
  value: BigInt!
}

input OperatorFeeIncreaseLimitUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OperatorFeeIncreaseLimitUpdated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [OperatorFeeIncreaseLimitUpdated_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum OperatorFeeIncreaseLimitUpdated_orderBy {
  blockNumber
  blockTimestamp
  id
  transactionHash
  value
}

type OperatorMaximumFeeUpdated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  maxFee: BigInt!
  transactionHash: Bytes!
}

input OperatorMaximumFeeUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OperatorMaximumFeeUpdated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  maxFee: BigInt
  maxFee_gt: BigInt
  maxFee_gte: BigInt
  maxFee_in: [BigInt!]
  maxFee_lt: BigInt
  maxFee_lte: BigInt
  maxFee_not: BigInt
  maxFee_not_in: [BigInt!]
  or: [OperatorMaximumFeeUpdated_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum OperatorMaximumFeeUpdated_orderBy {
  blockNumber
  blockTimestamp
  id
  maxFee
  transactionHash
}

type OperatorMultipleWhitelistRemoved {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  operatorIds: [BigInt!]!
  transactionHash: Bytes!
  whitelistAddresses: [Bytes!]
}

input OperatorMultipleWhitelistRemoved_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OperatorMultipleWhitelistRemoved_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorIds: [BigInt!]
  operatorIds_contains: [BigInt!]
  operatorIds_contains_nocase: [BigInt!]
  operatorIds_not: [BigInt!]
  operatorIds_not_contains: [BigInt!]
  operatorIds_not_contains_nocase: [BigInt!]
  or: [OperatorMultipleWhitelistRemoved_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  whitelistAddresses: [Bytes!]
  whitelistAddresses_contains: [Bytes!]
  whitelistAddresses_contains_nocase: [Bytes!]
  whitelistAddresses_not: [Bytes!]
  whitelistAddresses_not_contains: [Bytes!]
  whitelistAddresses_not_contains_nocase: [Bytes!]
}

enum OperatorMultipleWhitelistRemoved_orderBy {
  blockNumber
  blockTimestamp
  id
  operatorIds
  transactionHash
  whitelistAddresses
}

type OperatorMultipleWhitelistUpdated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  operatorIds: [BigInt!]!
  transactionHash: Bytes!
  whitelistAddresses: [Bytes!]
}

input OperatorMultipleWhitelistUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OperatorMultipleWhitelistUpdated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorIds: [BigInt!]
  operatorIds_contains: [BigInt!]
  operatorIds_contains_nocase: [BigInt!]
  operatorIds_not: [BigInt!]
  operatorIds_not_contains: [BigInt!]
  operatorIds_not_contains_nocase: [BigInt!]
  or: [OperatorMultipleWhitelistUpdated_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  whitelistAddresses: [Bytes!]
  whitelistAddresses_contains: [Bytes!]
  whitelistAddresses_contains_nocase: [Bytes!]
  whitelistAddresses_not: [Bytes!]
  whitelistAddresses_not_contains: [Bytes!]
  whitelistAddresses_not_contains_nocase: [Bytes!]
}

enum OperatorMultipleWhitelistUpdated_orderBy {
  blockNumber
  blockTimestamp
  id
  operatorIds
  transactionHash
  whitelistAddresses
}

type OperatorPrivacyStatusUpdated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  operatorIds: [BigInt!]!
  toPrivate: Boolean!
  transactionHash: Bytes!
}

input OperatorPrivacyStatusUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OperatorPrivacyStatusUpdated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorIds: [BigInt!]
  operatorIds_contains: [BigInt!]
  operatorIds_contains_nocase: [BigInt!]
  operatorIds_not: [BigInt!]
  operatorIds_not_contains: [BigInt!]
  operatorIds_not_contains_nocase: [BigInt!]
  or: [OperatorPrivacyStatusUpdated_filter]
  toPrivate: Boolean
  toPrivate_in: [Boolean!]
  toPrivate_not: Boolean
  toPrivate_not_in: [Boolean!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum OperatorPrivacyStatusUpdated_orderBy {
  blockNumber
  blockTimestamp
  id
  operatorIds
  toPrivate
  transactionHash
}

type OperatorRemoved {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  operatorId: BigInt!
  transactionHash: Bytes!
}

input OperatorRemoved_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OperatorRemoved_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorId: BigInt
  operatorId_gt: BigInt
  operatorId_gte: BigInt
  operatorId_in: [BigInt!]
  operatorId_lt: BigInt
  operatorId_lte: BigInt
  operatorId_not: BigInt
  operatorId_not_in: [BigInt!]
  or: [OperatorRemoved_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum OperatorRemoved_orderBy {
  blockNumber
  blockTimestamp
  id
  operatorId
  transactionHash
}

type OperatorWhitelistUpdated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  operatorId: BigInt!
  transactionHash: Bytes!
  whitelisted: Bytes!
}

input OperatorWhitelistUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OperatorWhitelistUpdated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorId: BigInt
  operatorId_gt: BigInt
  operatorId_gte: BigInt
  operatorId_in: [BigInt!]
  operatorId_lt: BigInt
  operatorId_lte: BigInt
  operatorId_not: BigInt
  operatorId_not_in: [BigInt!]
  or: [OperatorWhitelistUpdated_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  whitelisted: Bytes
  whitelisted_contains: Bytes
  whitelisted_gt: Bytes
  whitelisted_gte: Bytes
  whitelisted_in: [Bytes!]
  whitelisted_lt: Bytes
  whitelisted_lte: Bytes
  whitelisted_not: Bytes
  whitelisted_not_contains: Bytes
  whitelisted_not_in: [Bytes!]
}

enum OperatorWhitelistUpdated_orderBy {
  blockNumber
  blockTimestamp
  id
  operatorId
  transactionHash
  whitelisted
}

type OperatorWhitelistingContractUpdated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  operatorIds: [BigInt!]!
  transactionHash: Bytes!
  whitelistingContract: Bytes!
}

input OperatorWhitelistingContractUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OperatorWhitelistingContractUpdated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorIds: [BigInt!]
  operatorIds_contains: [BigInt!]
  operatorIds_contains_nocase: [BigInt!]
  operatorIds_not: [BigInt!]
  operatorIds_not_contains: [BigInt!]
  operatorIds_not_contains_nocase: [BigInt!]
  or: [OperatorWhitelistingContractUpdated_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  whitelistingContract: Bytes
  whitelistingContract_contains: Bytes
  whitelistingContract_gt: Bytes
  whitelistingContract_gte: Bytes
  whitelistingContract_in: [Bytes!]
  whitelistingContract_lt: Bytes
  whitelistingContract_lte: Bytes
  whitelistingContract_not: Bytes
  whitelistingContract_not_contains: Bytes
  whitelistingContract_not_in: [Bytes!]
}

enum OperatorWhitelistingContractUpdated_orderBy {
  blockNumber
  blockTimestamp
  id
  operatorIds
  transactionHash
  whitelistingContract
}

type OperatorWithdrawn {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  operatorId: BigInt!
  owner: Bytes!
  transactionHash: Bytes!
  value: BigInt!
}

input OperatorWithdrawn_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OperatorWithdrawn_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorId: BigInt
  operatorId_gt: BigInt
  operatorId_gte: BigInt
  operatorId_in: [BigInt!]
  operatorId_lt: BigInt
  operatorId_lte: BigInt
  operatorId_not: BigInt
  operatorId_not_in: [BigInt!]
  or: [OperatorWithdrawn_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum OperatorWithdrawn_orderBy {
  blockNumber
  blockTimestamp
  id
  operatorId
  owner
  transactionHash
  value
}

input Operator_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Operator_filter]
  declaredFee: BigInt
  declaredFee_gt: BigInt
  declaredFee_gte: BigInt
  declaredFee_in: [BigInt!]
  declaredFee_lt: BigInt
  declaredFee_lte: BigInt
  declaredFee_not: BigInt
  declaredFee_not_in: [BigInt!]
  fee: BigInt
  feeIndex: BigInt
  feeIndexBlockNumber: BigInt
  feeIndexBlockNumber_gt: BigInt
  feeIndexBlockNumber_gte: BigInt
  feeIndexBlockNumber_in: [BigInt!]
  feeIndexBlockNumber_lt: BigInt
  feeIndexBlockNumber_lte: BigInt
  feeIndexBlockNumber_not: BigInt
  feeIndexBlockNumber_not_in: [BigInt!]
  feeIndex_gt: BigInt
  feeIndex_gte: BigInt
  feeIndex_in: [BigInt!]
  feeIndex_lt: BigInt
  feeIndex_lte: BigInt
  feeIndex_not: BigInt
  feeIndex_not_in: [BigInt!]
  fee_gt: BigInt
  fee_gte: BigInt
  fee_in: [BigInt!]
  fee_lt: BigInt
  fee_lte: BigInt
  fee_not: BigInt
  fee_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  isPrivate: Boolean
  isPrivate_in: [Boolean!]
  isPrivate_not: Boolean
  isPrivate_not_in: [Boolean!]
  lastUpdateBlockNumber: BigInt
  lastUpdateBlockNumber_gt: BigInt
  lastUpdateBlockNumber_gte: BigInt
  lastUpdateBlockNumber_in: [BigInt!]
  lastUpdateBlockNumber_lt: BigInt
  lastUpdateBlockNumber_lte: BigInt
  lastUpdateBlockNumber_not: BigInt
  lastUpdateBlockNumber_not_in: [BigInt!]
  lastUpdateBlockTimestamp: BigInt
  lastUpdateBlockTimestamp_gt: BigInt
  lastUpdateBlockTimestamp_gte: BigInt
  lastUpdateBlockTimestamp_in: [BigInt!]
  lastUpdateBlockTimestamp_lt: BigInt
  lastUpdateBlockTimestamp_lte: BigInt
  lastUpdateBlockTimestamp_not: BigInt
  lastUpdateBlockTimestamp_not_in: [BigInt!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_gt: Bytes
  lastUpdateTransactionHash_gte: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_lt: Bytes
  lastUpdateTransactionHash_lte: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  lastUpdateTransactionHash_not_in: [Bytes!]
  operatorId: BigInt
  operatorId_gt: BigInt
  operatorId_gte: BigInt
  operatorId_in: [BigInt!]
  operatorId_lt: BigInt
  operatorId_lte: BigInt
  operatorId_not: BigInt
  operatorId_not_in: [BigInt!]
  or: [Operator_filter]
  owner: String
  owner_: Account_filter
  owner_contains: String
  owner_contains_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_gt: String
  owner_gte: String
  owner_in: [String!]
  owner_lt: String
  owner_lte: String
  owner_not: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_not_in: [String!]
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  publicKey: Bytes
  publicKey_contains: Bytes
  publicKey_gt: Bytes
  publicKey_gte: Bytes
  publicKey_in: [Bytes!]
  publicKey_lt: Bytes
  publicKey_lte: Bytes
  publicKey_not: Bytes
  publicKey_not_contains: Bytes
  publicKey_not_in: [Bytes!]
  removed: Boolean
  removed_in: [Boolean!]
  removed_not: Boolean
  removed_not_in: [Boolean!]
  totalWithdrawn: BigInt
  totalWithdrawn_gt: BigInt
  totalWithdrawn_gte: BigInt
  totalWithdrawn_in: [BigInt!]
  totalWithdrawn_lt: BigInt
  totalWithdrawn_lte: BigInt
  totalWithdrawn_not: BigInt
  totalWithdrawn_not_in: [BigInt!]
  validatorCount: BigInt
  validatorCount_gt: BigInt
  validatorCount_gte: BigInt
  validatorCount_in: [BigInt!]
  validatorCount_lt: BigInt
  validatorCount_lte: BigInt
  validatorCount_not: BigInt
  validatorCount_not_in: [BigInt!]
  validators_: Validator_filter
  whitelisted: [String!]
  whitelistedContract: Bytes
  whitelistedContract_contains: Bytes
  whitelistedContract_gt: Bytes
  whitelistedContract_gte: Bytes
  whitelistedContract_in: [Bytes!]
  whitelistedContract_lt: Bytes
  whitelistedContract_lte: Bytes
  whitelistedContract_not: Bytes
  whitelistedContract_not_contains: Bytes
  whitelistedContract_not_in: [Bytes!]
  whitelisted_: Account_filter
  whitelisted_contains: [String!]
  whitelisted_contains_nocase: [String!]
  whitelisted_not: [String!]
  whitelisted_not_contains: [String!]
  whitelisted_not_contains_nocase: [String!]
}

enum Operator_orderBy {
  declaredFee
  fee
  feeIndex
  feeIndexBlockNumber
  id
  isPrivate
  lastUpdateBlockNumber
  lastUpdateBlockTimestamp
  lastUpdateTransactionHash
  operatorId
  owner
  owner__feeRecipient
  owner__id
  owner__metadataURI
  owner__nonce
  owner__totalDelegatedPercentage
  owner__validatorCount
  publicKey
  removed
  totalWithdrawn
  validatorCount
  validators
  whitelisted
  whitelistedContract
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type OwnershipTransferred {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  newOwner: Bytes!
  previousOwner: Bytes!
  transactionHash: Bytes!
}

input OwnershipTransferred_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OwnershipTransferred_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  newOwner: Bytes
  newOwner_contains: Bytes
  newOwner_gt: Bytes
  newOwner_gte: Bytes
  newOwner_in: [Bytes!]
  newOwner_lt: Bytes
  newOwner_lte: Bytes
  newOwner_not: Bytes
  newOwner_not_contains: Bytes
  newOwner_not_in: [Bytes!]
  or: [OwnershipTransferred_filter]
  previousOwner: Bytes
  previousOwner_contains: Bytes
  previousOwner_gt: Bytes
  previousOwner_gte: Bytes
  previousOwner_in: [Bytes!]
  previousOwner_lt: Bytes
  previousOwner_lte: Bytes
  previousOwner_not: Bytes
  previousOwner_not_contains: Bytes
  previousOwner_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum OwnershipTransferred_orderBy {
  blockNumber
  blockTimestamp
  id
  newOwner
  previousOwner
  transactionHash
}

type Query {
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  account(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accountMetadataURIUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AccountMetadataURIUpdated
  accountMetadataURIUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AccountMetadataURIUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AccountMetadataURIUpdated_filter
  ): [AccountMetadataURIUpdated!]!
  accounts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Account_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Account_filter
  ): [Account!]!
  bapp(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BApp
  bappConstants(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BAppConstants
  bappConstants_collection(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BAppConstants_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BAppConstants_filter
  ): [BAppConstants!]!
  bappMetadataURIUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BAppMetadataURIUpdated
  bappMetadataURIUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BAppMetadataURIUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BAppMetadataURIUpdated_filter
  ): [BAppMetadataURIUpdated!]!
  bappOptedInByStrategies(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BAppOptedInByStrategy_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BAppOptedInByStrategy_filter
  ): [BAppOptedInByStrategy!]!
  bappOptedInByStrategy(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BAppOptedInByStrategy
  bappRegistered(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BAppRegistered
  bappRegistereds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BAppRegistered_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BAppRegistered_filter
  ): [BAppRegistered!]!
  bappToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BAppToken
  bappTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BAppToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BAppToken_filter
  ): [BAppToken!]!
  bappTokensCreated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BAppTokensCreated
  bappTokensCreateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BAppTokensCreated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BAppTokensCreated_filter
  ): [BAppTokensCreated!]!
  bappTokensUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BAppTokensUpdated
  bappTokensUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BAppTokensUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BAppTokensUpdated_filter
  ): [BAppTokensUpdated!]!
  bapps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BApp_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BApp_filter
  ): [BApp!]!
  cluster(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Cluster
  clusterDeposited(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ClusterDeposited
  clusterDepositeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ClusterDeposited_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ClusterDeposited_filter
  ): [ClusterDeposited!]!
  clusterLiquidated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ClusterLiquidated
  clusterLiquidateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ClusterLiquidated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ClusterLiquidated_filter
  ): [ClusterLiquidated!]!
  clusterReactivated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ClusterReactivated
  clusterReactivateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ClusterReactivated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ClusterReactivated_filter
  ): [ClusterReactivated!]!
  clusterWithdrawn(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ClusterWithdrawn
  clusterWithdrawns(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ClusterWithdrawn_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ClusterWithdrawn_filter
  ): [ClusterWithdrawn!]!
  clusters(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Cluster_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Cluster_filter
  ): [Cluster!]!
  daovalues(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DAOValues
  daovalues_collection(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DAOValues_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DAOValues_filter
  ): [DAOValues!]!
  declareOperatorFeePeriodUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DeclareOperatorFeePeriodUpdated
  declareOperatorFeePeriodUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DeclareOperatorFeePeriodUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DeclareOperatorFeePeriodUpdated_filter
  ): [DeclareOperatorFeePeriodUpdated!]!
  delegation(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Delegation
  delegationCreated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DelegationCreated
  delegationCreateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DelegationCreated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DelegationCreated_filter
  ): [DelegationCreated!]!
  delegationRemoved(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DelegationRemoved
  delegationRemoveds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DelegationRemoved_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DelegationRemoved_filter
  ): [DelegationRemoved!]!
  delegationUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DelegationUpdated
  delegationUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DelegationUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DelegationUpdated_filter
  ): [DelegationUpdated!]!
  delegations(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Delegation_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Delegation_filter
  ): [Delegation!]!
  executeOperatorFeePeriodUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ExecuteOperatorFeePeriodUpdated
  executeOperatorFeePeriodUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ExecuteOperatorFeePeriodUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ExecuteOperatorFeePeriodUpdated_filter
  ): [ExecuteOperatorFeePeriodUpdated!]!
  feeRecipientAddressUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FeeRecipientAddressUpdated
  feeRecipientAddressUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FeeRecipientAddressUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FeeRecipientAddressUpdated_filter
  ): [FeeRecipientAddressUpdated!]!
  initialized(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Initialized
  initializeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Initialized_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Initialized_filter
  ): [Initialized!]!
  liquidationThresholdPeriodUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidationThresholdPeriodUpdated
  liquidationThresholdPeriodUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidationThresholdPeriodUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidationThresholdPeriodUpdated_filter
  ): [LiquidationThresholdPeriodUpdated!]!
  maxFeeIncrementSet(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MaxFeeIncrementSet
  maxFeeIncrementSets(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MaxFeeIncrementSet_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MaxFeeIncrementSet_filter
  ): [MaxFeeIncrementSet!]!
  minimumLiquidationCollateralUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MinimumLiquidationCollateralUpdated
  minimumLiquidationCollateralUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MinimumLiquidationCollateralUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MinimumLiquidationCollateralUpdated_filter
  ): [MinimumLiquidationCollateralUpdated!]!
  networkEarningsWithdrawn(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NetworkEarningsWithdrawn
  networkEarningsWithdrawns(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NetworkEarningsWithdrawn_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NetworkEarningsWithdrawn_filter
  ): [NetworkEarningsWithdrawn!]!
  networkFeeUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NetworkFeeUpdated
  networkFeeUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NetworkFeeUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NetworkFeeUpdated_filter
  ): [NetworkFeeUpdated!]!
  obligation(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Obligation
  obligationCreated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ObligationCreated
  obligationCreateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ObligationCreated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ObligationCreated_filter
  ): [ObligationCreated!]!
  obligationUpdateProposed(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ObligationUpdateProposed
  obligationUpdateProposeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ObligationUpdateProposed_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ObligationUpdateProposed_filter
  ): [ObligationUpdateProposed!]!
  obligationUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ObligationUpdated
  obligationUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ObligationUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ObligationUpdated_filter
  ): [ObligationUpdated!]!
  obligations(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Obligation_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Obligation_filter
  ): [Obligation!]!
  operator(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Operator
  operatorAdded(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorAdded
  operatorAddeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorAdded_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorAdded_filter
  ): [OperatorAdded!]!
  operatorFeeDeclarationCancelled(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorFeeDeclarationCancelled
  operatorFeeDeclarationCancelleds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorFeeDeclarationCancelled_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorFeeDeclarationCancelled_filter
  ): [OperatorFeeDeclarationCancelled!]!
  operatorFeeDeclared(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorFeeDeclared
  operatorFeeDeclareds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorFeeDeclared_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorFeeDeclared_filter
  ): [OperatorFeeDeclared!]!
  operatorFeeExecuted(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorFeeExecuted
  operatorFeeExecuteds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorFeeExecuted_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorFeeExecuted_filter
  ): [OperatorFeeExecuted!]!
  operatorFeeIncreaseLimitUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorFeeIncreaseLimitUpdated
  operatorFeeIncreaseLimitUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorFeeIncreaseLimitUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorFeeIncreaseLimitUpdated_filter
  ): [OperatorFeeIncreaseLimitUpdated!]!
  operatorMaximumFeeUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorMaximumFeeUpdated
  operatorMaximumFeeUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorMaximumFeeUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorMaximumFeeUpdated_filter
  ): [OperatorMaximumFeeUpdated!]!
  operatorMultipleWhitelistRemoved(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorMultipleWhitelistRemoved
  operatorMultipleWhitelistRemoveds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorMultipleWhitelistRemoved_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorMultipleWhitelistRemoved_filter
  ): [OperatorMultipleWhitelistRemoved!]!
  operatorMultipleWhitelistUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorMultipleWhitelistUpdated
  operatorMultipleWhitelistUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorMultipleWhitelistUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorMultipleWhitelistUpdated_filter
  ): [OperatorMultipleWhitelistUpdated!]!
  operatorPrivacyStatusUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorPrivacyStatusUpdated
  operatorPrivacyStatusUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorPrivacyStatusUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorPrivacyStatusUpdated_filter
  ): [OperatorPrivacyStatusUpdated!]!
  operatorRemoved(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorRemoved
  operatorRemoveds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorRemoved_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorRemoved_filter
  ): [OperatorRemoved!]!
  operatorWhitelistUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorWhitelistUpdated
  operatorWhitelistUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorWhitelistUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorWhitelistUpdated_filter
  ): [OperatorWhitelistUpdated!]!
  operatorWhitelistingContractUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorWhitelistingContractUpdated
  operatorWhitelistingContractUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorWhitelistingContractUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorWhitelistingContractUpdated_filter
  ): [OperatorWhitelistingContractUpdated!]!
  operatorWithdrawn(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorWithdrawn
  operatorWithdrawns(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorWithdrawn_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorWithdrawn_filter
  ): [OperatorWithdrawn!]!
  operators(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Operator_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Operator_filter
  ): [Operator!]!
  ownershipTransferred(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OwnershipTransferred
  ownershipTransferreds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OwnershipTransferred_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OwnershipTransferred_filter
  ): [OwnershipTransferred!]!
  strategies(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Strategy_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Strategy_filter
  ): [Strategy!]!
  strategy(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Strategy
  strategyBAppOptIn(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StrategyBAppOptIn
  strategyBAppOptIns(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StrategyBAppOptIn_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StrategyBAppOptIn_filter
  ): [StrategyBAppOptIn!]!
  strategyCreated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StrategyCreated
  strategyCreateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StrategyCreated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StrategyCreated_filter
  ): [StrategyCreated!]!
  strategyDeposit(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StrategyDeposit
  strategyDeposits(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StrategyDeposit_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StrategyDeposit_filter
  ): [StrategyDeposit!]!
  strategyFeeUpdateProposed(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StrategyFeeUpdateProposed
  strategyFeeUpdateProposeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StrategyFeeUpdateProposed_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StrategyFeeUpdateProposed_filter
  ): [StrategyFeeUpdateProposed!]!
  strategyFeeUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StrategyFeeUpdated
  strategyFeeUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StrategyFeeUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StrategyFeeUpdated_filter
  ): [StrategyFeeUpdated!]!
  strategyMetadataURIUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StrategyMetadataURIUpdated
  strategyMetadataURIUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StrategyMetadataURIUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StrategyMetadataURIUpdated_filter
  ): [StrategyMetadataURIUpdated!]!
  strategyTokenBalance(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StrategyTokenBalance
  strategyTokenBalances(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StrategyTokenBalance_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StrategyTokenBalance_filter
  ): [StrategyTokenBalance!]!
  strategyUserBalance(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StrategyUserBalance
  strategyUserBalances(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StrategyUserBalance_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StrategyUserBalance_filter
  ): [StrategyUserBalance!]!
  strategyWithdrawal(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StrategyWithdrawal
  strategyWithdrawalProposed(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StrategyWithdrawalProposed
  strategyWithdrawalProposeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StrategyWithdrawalProposed_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StrategyWithdrawalProposed_filter
  ): [StrategyWithdrawalProposed!]!
  strategyWithdrawals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StrategyWithdrawal_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StrategyWithdrawal_filter
  ): [StrategyWithdrawal!]!
  upgraded(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Upgraded
  upgradeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Upgraded_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Upgraded_filter
  ): [Upgraded!]!
  validator(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Validator
  validatorAdded(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ValidatorAdded
  validatorAddeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ValidatorAdded_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ValidatorAdded_filter
  ): [ValidatorAdded!]!
  validatorRemoved(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ValidatorRemoved
  validatorRemoveds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ValidatorRemoved_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ValidatorRemoved_filter
  ): [ValidatorRemoved!]!
  validators(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Validator_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Validator_filter
  ): [Validator!]!
}

type Strategy {
  bApps(first: Int = 100, orderBy: StrategyBAppOptIn_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: StrategyBAppOptIn_filter): [StrategyBAppOptIn!]!
  balances(first: Int = 100, orderBy: StrategyTokenBalance_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: StrategyTokenBalance_filter): [StrategyTokenBalance!]!
  deposits(first: Int = 100, orderBy: StrategyUserBalance_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: StrategyUserBalance_filter): [StrategyUserBalance!]!
  fee: BigInt!
  feeProposed: BigInt!
  feeProposedTimestamp: BigInt!
  id: String!
  metadataURI: String
  owner: Account!
  strategyId: BigInt!
}

type StrategyBAppOptIn {
  bApp: BApp!
  id: String!
  obligations(first: Int = 100, orderBy: Obligation_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Obligation_filter): [Obligation!]!
  strategy: Strategy!
}

input StrategyBAppOptIn_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [StrategyBAppOptIn_filter]
  bApp: String
  bApp_: BApp_filter
  bApp_contains: String
  bApp_contains_nocase: String
  bApp_ends_with: String
  bApp_ends_with_nocase: String
  bApp_gt: String
  bApp_gte: String
  bApp_in: [String!]
  bApp_lt: String
  bApp_lte: String
  bApp_not: String
  bApp_not_contains: String
  bApp_not_contains_nocase: String
  bApp_not_ends_with: String
  bApp_not_ends_with_nocase: String
  bApp_not_in: [String!]
  bApp_not_starts_with: String
  bApp_not_starts_with_nocase: String
  bApp_starts_with: String
  bApp_starts_with_nocase: String
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  obligations_: Obligation_filter
  or: [StrategyBAppOptIn_filter]
  strategy: String
  strategy_: Strategy_filter
  strategy_contains: String
  strategy_contains_nocase: String
  strategy_ends_with: String
  strategy_ends_with_nocase: String
  strategy_gt: String
  strategy_gte: String
  strategy_in: [String!]
  strategy_lt: String
  strategy_lte: String
  strategy_not: String
  strategy_not_contains: String
  strategy_not_contains_nocase: String
  strategy_not_ends_with: String
  strategy_not_ends_with_nocase: String
  strategy_not_in: [String!]
  strategy_not_starts_with: String
  strategy_not_starts_with_nocase: String
  strategy_starts_with: String
  strategy_starts_with_nocase: String
}

enum StrategyBAppOptIn_orderBy {
  bApp
  bApp__id
  bApp__metadataURI
  id
  obligations
  strategy
  strategy__fee
  strategy__feeProposed
  strategy__feeProposedTimestamp
  strategy__id
  strategy__metadataURI
  strategy__strategyId
}

type StrategyCreated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  fee: BigInt!
  id: Bytes!
  metadataURI: String
  owner: Bytes!
  strategyId: BigInt!
  transactionHash: Bytes!
}

input StrategyCreated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [StrategyCreated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  fee: BigInt
  fee_gt: BigInt
  fee_gte: BigInt
  fee_in: [BigInt!]
  fee_lt: BigInt
  fee_lte: BigInt
  fee_not: BigInt
  fee_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  metadataURI: String
  metadataURI_contains: String
  metadataURI_contains_nocase: String
  metadataURI_ends_with: String
  metadataURI_ends_with_nocase: String
  metadataURI_gt: String
  metadataURI_gte: String
  metadataURI_in: [String!]
  metadataURI_lt: String
  metadataURI_lte: String
  metadataURI_not: String
  metadataURI_not_contains: String
  metadataURI_not_contains_nocase: String
  metadataURI_not_ends_with: String
  metadataURI_not_ends_with_nocase: String
  metadataURI_not_in: [String!]
  metadataURI_not_starts_with: String
  metadataURI_not_starts_with_nocase: String
  metadataURI_starts_with: String
  metadataURI_starts_with_nocase: String
  or: [StrategyCreated_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  strategyId: BigInt
  strategyId_gt: BigInt
  strategyId_gte: BigInt
  strategyId_in: [BigInt!]
  strategyId_lt: BigInt
  strategyId_lte: BigInt
  strategyId_not: BigInt
  strategyId_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum StrategyCreated_orderBy {
  blockNumber
  blockTimestamp
  fee
  id
  metadataURI
  owner
  strategyId
  transactionHash
}

type StrategyDeposit {
  amount: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  contributor: Bytes!
  id: Bytes!
  strategyId: BigInt!
  token: Bytes!
  transactionHash: Bytes!
}

input StrategyDeposit_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  and: [StrategyDeposit_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  contributor: Bytes
  contributor_contains: Bytes
  contributor_gt: Bytes
  contributor_gte: Bytes
  contributor_in: [Bytes!]
  contributor_lt: Bytes
  contributor_lte: Bytes
  contributor_not: Bytes
  contributor_not_contains: Bytes
  contributor_not_in: [Bytes!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [StrategyDeposit_filter]
  strategyId: BigInt
  strategyId_gt: BigInt
  strategyId_gte: BigInt
  strategyId_in: [BigInt!]
  strategyId_lt: BigInt
  strategyId_lte: BigInt
  strategyId_not: BigInt
  strategyId_not_in: [BigInt!]
  token: Bytes
  token_contains: Bytes
  token_gt: Bytes
  token_gte: Bytes
  token_in: [Bytes!]
  token_lt: Bytes
  token_lte: Bytes
  token_not: Bytes
  token_not_contains: Bytes
  token_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum StrategyDeposit_orderBy {
  amount
  blockNumber
  blockTimestamp
  contributor
  id
  strategyId
  token
  transactionHash
}

type StrategyFeeUpdateProposed {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  fee: BigInt!
  id: Bytes!
  owner: Bytes!
  proposedFee: BigInt!
  strategyId: BigInt!
  transactionHash: Bytes!
}

input StrategyFeeUpdateProposed_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [StrategyFeeUpdateProposed_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  fee: BigInt
  fee_gt: BigInt
  fee_gte: BigInt
  fee_in: [BigInt!]
  fee_lt: BigInt
  fee_lte: BigInt
  fee_not: BigInt
  fee_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [StrategyFeeUpdateProposed_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  proposedFee: BigInt
  proposedFee_gt: BigInt
  proposedFee_gte: BigInt
  proposedFee_in: [BigInt!]
  proposedFee_lt: BigInt
  proposedFee_lte: BigInt
  proposedFee_not: BigInt
  proposedFee_not_in: [BigInt!]
  strategyId: BigInt
  strategyId_gt: BigInt
  strategyId_gte: BigInt
  strategyId_in: [BigInt!]
  strategyId_lt: BigInt
  strategyId_lte: BigInt
  strategyId_not: BigInt
  strategyId_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum StrategyFeeUpdateProposed_orderBy {
  blockNumber
  blockTimestamp
  fee
  id
  owner
  proposedFee
  strategyId
  transactionHash
}

type StrategyFeeUpdated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  fee: BigInt!
  id: Bytes!
  oldFee: BigInt!
  owner: Bytes!
  strategyId: BigInt!
  transactionHash: Bytes!
}

input StrategyFeeUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [StrategyFeeUpdated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  fee: BigInt
  fee_gt: BigInt
  fee_gte: BigInt
  fee_in: [BigInt!]
  fee_lt: BigInt
  fee_lte: BigInt
  fee_not: BigInt
  fee_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  oldFee: BigInt
  oldFee_gt: BigInt
  oldFee_gte: BigInt
  oldFee_in: [BigInt!]
  oldFee_lt: BigInt
  oldFee_lte: BigInt
  oldFee_not: BigInt
  oldFee_not_in: [BigInt!]
  or: [StrategyFeeUpdated_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  strategyId: BigInt
  strategyId_gt: BigInt
  strategyId_gte: BigInt
  strategyId_in: [BigInt!]
  strategyId_lt: BigInt
  strategyId_lte: BigInt
  strategyId_not: BigInt
  strategyId_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum StrategyFeeUpdated_orderBy {
  blockNumber
  blockTimestamp
  fee
  id
  oldFee
  owner
  strategyId
  transactionHash
}

type StrategyMetadataURIUpdated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  metadataURI: String!
  strategyId: BigInt!
  transactionHash: Bytes!
}

input StrategyMetadataURIUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [StrategyMetadataURIUpdated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  metadataURI: String
  metadataURI_contains: String
  metadataURI_contains_nocase: String
  metadataURI_ends_with: String
  metadataURI_ends_with_nocase: String
  metadataURI_gt: String
  metadataURI_gte: String
  metadataURI_in: [String!]
  metadataURI_lt: String
  metadataURI_lte: String
  metadataURI_not: String
  metadataURI_not_contains: String
  metadataURI_not_contains_nocase: String
  metadataURI_not_ends_with: String
  metadataURI_not_ends_with_nocase: String
  metadataURI_not_in: [String!]
  metadataURI_not_starts_with: String
  metadataURI_not_starts_with_nocase: String
  metadataURI_starts_with: String
  metadataURI_starts_with_nocase: String
  or: [StrategyMetadataURIUpdated_filter]
  strategyId: BigInt
  strategyId_gt: BigInt
  strategyId_gte: BigInt
  strategyId_in: [BigInt!]
  strategyId_lt: BigInt
  strategyId_lte: BigInt
  strategyId_not: BigInt
  strategyId_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum StrategyMetadataURIUpdated_orderBy {
  blockNumber
  blockTimestamp
  id
  metadataURI
  strategyId
  transactionHash
}

type StrategyTokenBalance {
  balance: BigInt!
  id: String!
  riskValue: BigInt!
  strategy: Strategy!
  token: Bytes!
}

input StrategyTokenBalance_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [StrategyTokenBalance_filter]
  balance: BigInt
  balance_gt: BigInt
  balance_gte: BigInt
  balance_in: [BigInt!]
  balance_lt: BigInt
  balance_lte: BigInt
  balance_not: BigInt
  balance_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [StrategyTokenBalance_filter]
  riskValue: BigInt
  riskValue_gt: BigInt
  riskValue_gte: BigInt
  riskValue_in: [BigInt!]
  riskValue_lt: BigInt
  riskValue_lte: BigInt
  riskValue_not: BigInt
  riskValue_not_in: [BigInt!]
  strategy: String
  strategy_: Strategy_filter
  strategy_contains: String
  strategy_contains_nocase: String
  strategy_ends_with: String
  strategy_ends_with_nocase: String
  strategy_gt: String
  strategy_gte: String
  strategy_in: [String!]
  strategy_lt: String
  strategy_lte: String
  strategy_not: String
  strategy_not_contains: String
  strategy_not_contains_nocase: String
  strategy_not_ends_with: String
  strategy_not_ends_with_nocase: String
  strategy_not_in: [String!]
  strategy_not_starts_with: String
  strategy_not_starts_with_nocase: String
  strategy_starts_with: String
  strategy_starts_with_nocase: String
  token: Bytes
  token_contains: Bytes
  token_gt: Bytes
  token_gte: Bytes
  token_in: [Bytes!]
  token_lt: Bytes
  token_lte: Bytes
  token_not: Bytes
  token_not_contains: Bytes
  token_not_in: [Bytes!]
}

enum StrategyTokenBalance_orderBy {
  balance
  id
  riskValue
  strategy
  strategy__fee
  strategy__feeProposed
  strategy__feeProposedTimestamp
  strategy__id
  strategy__metadataURI
  strategy__strategyId
  token
}

type StrategyUserBalance {
  contributor: Account!
  depositAmount: BigInt!
  id: String!
  proposedWithdrawal: BigInt!
  proposedWithdrawalTimestamp: BigInt!
  strategy: Strategy!
  token: Bytes!
}

input StrategyUserBalance_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [StrategyUserBalance_filter]
  contributor: String
  contributor_: Account_filter
  contributor_contains: String
  contributor_contains_nocase: String
  contributor_ends_with: String
  contributor_ends_with_nocase: String
  contributor_gt: String
  contributor_gte: String
  contributor_in: [String!]
  contributor_lt: String
  contributor_lte: String
  contributor_not: String
  contributor_not_contains: String
  contributor_not_contains_nocase: String
  contributor_not_ends_with: String
  contributor_not_ends_with_nocase: String
  contributor_not_in: [String!]
  contributor_not_starts_with: String
  contributor_not_starts_with_nocase: String
  contributor_starts_with: String
  contributor_starts_with_nocase: String
  depositAmount: BigInt
  depositAmount_gt: BigInt
  depositAmount_gte: BigInt
  depositAmount_in: [BigInt!]
  depositAmount_lt: BigInt
  depositAmount_lte: BigInt
  depositAmount_not: BigInt
  depositAmount_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [StrategyUserBalance_filter]
  proposedWithdrawal: BigInt
  proposedWithdrawalTimestamp: BigInt
  proposedWithdrawalTimestamp_gt: BigInt
  proposedWithdrawalTimestamp_gte: BigInt
  proposedWithdrawalTimestamp_in: [BigInt!]
  proposedWithdrawalTimestamp_lt: BigInt
  proposedWithdrawalTimestamp_lte: BigInt
  proposedWithdrawalTimestamp_not: BigInt
  proposedWithdrawalTimestamp_not_in: [BigInt!]
  proposedWithdrawal_gt: BigInt
  proposedWithdrawal_gte: BigInt
  proposedWithdrawal_in: [BigInt!]
  proposedWithdrawal_lt: BigInt
  proposedWithdrawal_lte: BigInt
  proposedWithdrawal_not: BigInt
  proposedWithdrawal_not_in: [BigInt!]
  strategy: String
  strategy_: Strategy_filter
  strategy_contains: String
  strategy_contains_nocase: String
  strategy_ends_with: String
  strategy_ends_with_nocase: String
  strategy_gt: String
  strategy_gte: String
  strategy_in: [String!]
  strategy_lt: String
  strategy_lte: String
  strategy_not: String
  strategy_not_contains: String
  strategy_not_contains_nocase: String
  strategy_not_ends_with: String
  strategy_not_ends_with_nocase: String
  strategy_not_in: [String!]
  strategy_not_starts_with: String
  strategy_not_starts_with_nocase: String
  strategy_starts_with: String
  strategy_starts_with_nocase: String
  token: Bytes
  token_contains: Bytes
  token_gt: Bytes
  token_gte: Bytes
  token_in: [Bytes!]
  token_lt: Bytes
  token_lte: Bytes
  token_not: Bytes
  token_not_contains: Bytes
  token_not_in: [Bytes!]
}

enum StrategyUserBalance_orderBy {
  contributor
  contributor__feeRecipient
  contributor__id
  contributor__metadataURI
  contributor__nonce
  contributor__totalDelegatedPercentage
  contributor__validatorCount
  depositAmount
  id
  proposedWithdrawal
  proposedWithdrawalTimestamp
  strategy
  strategy__fee
  strategy__feeProposed
  strategy__feeProposedTimestamp
  strategy__id
  strategy__metadataURI
  strategy__strategyId
  token
}

type StrategyWithdrawal {
  amount: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  contributor: Bytes!
  id: Bytes!
  isFast: Boolean!
  strategyId: BigInt!
  token: Bytes!
  transactionHash: Bytes!
}

type StrategyWithdrawalProposed {
  account: Bytes!
  amount: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  strategyId: BigInt!
  token: Bytes!
  transactionHash: Bytes!
}

input StrategyWithdrawalProposed_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  and: [StrategyWithdrawalProposed_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [StrategyWithdrawalProposed_filter]
  strategyId: BigInt
  strategyId_gt: BigInt
  strategyId_gte: BigInt
  strategyId_in: [BigInt!]
  strategyId_lt: BigInt
  strategyId_lte: BigInt
  strategyId_not: BigInt
  strategyId_not_in: [BigInt!]
  token: Bytes
  token_contains: Bytes
  token_gt: Bytes
  token_gte: Bytes
  token_in: [Bytes!]
  token_lt: Bytes
  token_lte: Bytes
  token_not: Bytes
  token_not_contains: Bytes
  token_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum StrategyWithdrawalProposed_orderBy {
  account
  amount
  blockNumber
  blockTimestamp
  id
  strategyId
  token
  transactionHash
}

input StrategyWithdrawal_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  and: [StrategyWithdrawal_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  contributor: Bytes
  contributor_contains: Bytes
  contributor_gt: Bytes
  contributor_gte: Bytes
  contributor_in: [Bytes!]
  contributor_lt: Bytes
  contributor_lte: Bytes
  contributor_not: Bytes
  contributor_not_contains: Bytes
  contributor_not_in: [Bytes!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  isFast: Boolean
  isFast_in: [Boolean!]
  isFast_not: Boolean
  isFast_not_in: [Boolean!]
  or: [StrategyWithdrawal_filter]
  strategyId: BigInt
  strategyId_gt: BigInt
  strategyId_gte: BigInt
  strategyId_in: [BigInt!]
  strategyId_lt: BigInt
  strategyId_lte: BigInt
  strategyId_not: BigInt
  strategyId_not_in: [BigInt!]
  token: Bytes
  token_contains: Bytes
  token_gt: Bytes
  token_gte: Bytes
  token_in: [Bytes!]
  token_lt: Bytes
  token_lte: Bytes
  token_not: Bytes
  token_not_contains: Bytes
  token_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum StrategyWithdrawal_orderBy {
  amount
  blockNumber
  blockTimestamp
  contributor
  id
  isFast
  strategyId
  token
  transactionHash
}

input Strategy_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Strategy_filter]
  bApps_: StrategyBAppOptIn_filter
  balances_: StrategyTokenBalance_filter
  deposits_: StrategyUserBalance_filter
  fee: BigInt
  feeProposed: BigInt
  feeProposedTimestamp: BigInt
  feeProposedTimestamp_gt: BigInt
  feeProposedTimestamp_gte: BigInt
  feeProposedTimestamp_in: [BigInt!]
  feeProposedTimestamp_lt: BigInt
  feeProposedTimestamp_lte: BigInt
  feeProposedTimestamp_not: BigInt
  feeProposedTimestamp_not_in: [BigInt!]
  feeProposed_gt: BigInt
  feeProposed_gte: BigInt
  feeProposed_in: [BigInt!]
  feeProposed_lt: BigInt
  feeProposed_lte: BigInt
  feeProposed_not: BigInt
  feeProposed_not_in: [BigInt!]
  fee_gt: BigInt
  fee_gte: BigInt
  fee_in: [BigInt!]
  fee_lt: BigInt
  fee_lte: BigInt
  fee_not: BigInt
  fee_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  metadataURI: String
  metadataURI_contains: String
  metadataURI_contains_nocase: String
  metadataURI_ends_with: String
  metadataURI_ends_with_nocase: String
  metadataURI_gt: String
  metadataURI_gte: String
  metadataURI_in: [String!]
  metadataURI_lt: String
  metadataURI_lte: String
  metadataURI_not: String
  metadataURI_not_contains: String
  metadataURI_not_contains_nocase: String
  metadataURI_not_ends_with: String
  metadataURI_not_ends_with_nocase: String
  metadataURI_not_in: [String!]
  metadataURI_not_starts_with: String
  metadataURI_not_starts_with_nocase: String
  metadataURI_starts_with: String
  metadataURI_starts_with_nocase: String
  or: [Strategy_filter]
  owner: String
  owner_: Account_filter
  owner_contains: String
  owner_contains_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_gt: String
  owner_gte: String
  owner_in: [String!]
  owner_lt: String
  owner_lte: String
  owner_not: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_not_in: [String!]
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  strategyId: BigInt
  strategyId_gt: BigInt
  strategyId_gte: BigInt
  strategyId_in: [BigInt!]
  strategyId_lt: BigInt
  strategyId_lte: BigInt
  strategyId_not: BigInt
  strategyId_not_in: [BigInt!]
}

enum Strategy_orderBy {
  bApps
  balances
  deposits
  fee
  feeProposed
  feeProposedTimestamp
  id
  metadataURI
  owner
  owner__feeRecipient
  owner__id
  owner__metadataURI
  owner__nonce
  owner__totalDelegatedPercentage
  owner__validatorCount
  strategyId
}

type Subscription {
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  account(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accountMetadataURIUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AccountMetadataURIUpdated
  accountMetadataURIUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AccountMetadataURIUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AccountMetadataURIUpdated_filter
  ): [AccountMetadataURIUpdated!]!
  accounts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Account_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Account_filter
  ): [Account!]!
  bapp(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BApp
  bappConstants(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BAppConstants
  bappConstants_collection(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BAppConstants_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BAppConstants_filter
  ): [BAppConstants!]!
  bappMetadataURIUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BAppMetadataURIUpdated
  bappMetadataURIUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BAppMetadataURIUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BAppMetadataURIUpdated_filter
  ): [BAppMetadataURIUpdated!]!
  bappOptedInByStrategies(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BAppOptedInByStrategy_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BAppOptedInByStrategy_filter
  ): [BAppOptedInByStrategy!]!
  bappOptedInByStrategy(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BAppOptedInByStrategy
  bappRegistered(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BAppRegistered
  bappRegistereds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BAppRegistered_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BAppRegistered_filter
  ): [BAppRegistered!]!
  bappToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BAppToken
  bappTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BAppToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BAppToken_filter
  ): [BAppToken!]!
  bappTokensCreated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BAppTokensCreated
  bappTokensCreateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BAppTokensCreated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BAppTokensCreated_filter
  ): [BAppTokensCreated!]!
  bappTokensUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BAppTokensUpdated
  bappTokensUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BAppTokensUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BAppTokensUpdated_filter
  ): [BAppTokensUpdated!]!
  bapps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BApp_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BApp_filter
  ): [BApp!]!
  cluster(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Cluster
  clusterDeposited(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ClusterDeposited
  clusterDepositeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ClusterDeposited_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ClusterDeposited_filter
  ): [ClusterDeposited!]!
  clusterLiquidated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ClusterLiquidated
  clusterLiquidateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ClusterLiquidated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ClusterLiquidated_filter
  ): [ClusterLiquidated!]!
  clusterReactivated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ClusterReactivated
  clusterReactivateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ClusterReactivated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ClusterReactivated_filter
  ): [ClusterReactivated!]!
  clusterWithdrawn(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ClusterWithdrawn
  clusterWithdrawns(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ClusterWithdrawn_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ClusterWithdrawn_filter
  ): [ClusterWithdrawn!]!
  clusters(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Cluster_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Cluster_filter
  ): [Cluster!]!
  daovalues(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DAOValues
  daovalues_collection(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DAOValues_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DAOValues_filter
  ): [DAOValues!]!
  declareOperatorFeePeriodUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DeclareOperatorFeePeriodUpdated
  declareOperatorFeePeriodUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DeclareOperatorFeePeriodUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DeclareOperatorFeePeriodUpdated_filter
  ): [DeclareOperatorFeePeriodUpdated!]!
  delegation(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Delegation
  delegationCreated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DelegationCreated
  delegationCreateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DelegationCreated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DelegationCreated_filter
  ): [DelegationCreated!]!
  delegationRemoved(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DelegationRemoved
  delegationRemoveds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DelegationRemoved_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DelegationRemoved_filter
  ): [DelegationRemoved!]!
  delegationUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DelegationUpdated
  delegationUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DelegationUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DelegationUpdated_filter
  ): [DelegationUpdated!]!
  delegations(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Delegation_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Delegation_filter
  ): [Delegation!]!
  executeOperatorFeePeriodUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ExecuteOperatorFeePeriodUpdated
  executeOperatorFeePeriodUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ExecuteOperatorFeePeriodUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ExecuteOperatorFeePeriodUpdated_filter
  ): [ExecuteOperatorFeePeriodUpdated!]!
  feeRecipientAddressUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FeeRecipientAddressUpdated
  feeRecipientAddressUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FeeRecipientAddressUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FeeRecipientAddressUpdated_filter
  ): [FeeRecipientAddressUpdated!]!
  initialized(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Initialized
  initializeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Initialized_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Initialized_filter
  ): [Initialized!]!
  liquidationThresholdPeriodUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidationThresholdPeriodUpdated
  liquidationThresholdPeriodUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidationThresholdPeriodUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidationThresholdPeriodUpdated_filter
  ): [LiquidationThresholdPeriodUpdated!]!
  maxFeeIncrementSet(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MaxFeeIncrementSet
  maxFeeIncrementSets(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MaxFeeIncrementSet_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MaxFeeIncrementSet_filter
  ): [MaxFeeIncrementSet!]!
  minimumLiquidationCollateralUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MinimumLiquidationCollateralUpdated
  minimumLiquidationCollateralUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MinimumLiquidationCollateralUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MinimumLiquidationCollateralUpdated_filter
  ): [MinimumLiquidationCollateralUpdated!]!
  networkEarningsWithdrawn(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NetworkEarningsWithdrawn
  networkEarningsWithdrawns(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NetworkEarningsWithdrawn_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NetworkEarningsWithdrawn_filter
  ): [NetworkEarningsWithdrawn!]!
  networkFeeUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NetworkFeeUpdated
  networkFeeUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NetworkFeeUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NetworkFeeUpdated_filter
  ): [NetworkFeeUpdated!]!
  obligation(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Obligation
  obligationCreated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ObligationCreated
  obligationCreateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ObligationCreated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ObligationCreated_filter
  ): [ObligationCreated!]!
  obligationUpdateProposed(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ObligationUpdateProposed
  obligationUpdateProposeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ObligationUpdateProposed_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ObligationUpdateProposed_filter
  ): [ObligationUpdateProposed!]!
  obligationUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ObligationUpdated
  obligationUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ObligationUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ObligationUpdated_filter
  ): [ObligationUpdated!]!
  obligations(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Obligation_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Obligation_filter
  ): [Obligation!]!
  operator(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Operator
  operatorAdded(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorAdded
  operatorAddeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorAdded_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorAdded_filter
  ): [OperatorAdded!]!
  operatorFeeDeclarationCancelled(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorFeeDeclarationCancelled
  operatorFeeDeclarationCancelleds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorFeeDeclarationCancelled_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorFeeDeclarationCancelled_filter
  ): [OperatorFeeDeclarationCancelled!]!
  operatorFeeDeclared(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorFeeDeclared
  operatorFeeDeclareds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorFeeDeclared_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorFeeDeclared_filter
  ): [OperatorFeeDeclared!]!
  operatorFeeExecuted(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorFeeExecuted
  operatorFeeExecuteds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorFeeExecuted_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorFeeExecuted_filter
  ): [OperatorFeeExecuted!]!
  operatorFeeIncreaseLimitUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorFeeIncreaseLimitUpdated
  operatorFeeIncreaseLimitUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorFeeIncreaseLimitUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorFeeIncreaseLimitUpdated_filter
  ): [OperatorFeeIncreaseLimitUpdated!]!
  operatorMaximumFeeUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorMaximumFeeUpdated
  operatorMaximumFeeUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorMaximumFeeUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorMaximumFeeUpdated_filter
  ): [OperatorMaximumFeeUpdated!]!
  operatorMultipleWhitelistRemoved(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorMultipleWhitelistRemoved
  operatorMultipleWhitelistRemoveds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorMultipleWhitelistRemoved_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorMultipleWhitelistRemoved_filter
  ): [OperatorMultipleWhitelistRemoved!]!
  operatorMultipleWhitelistUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorMultipleWhitelistUpdated
  operatorMultipleWhitelistUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorMultipleWhitelistUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorMultipleWhitelistUpdated_filter
  ): [OperatorMultipleWhitelistUpdated!]!
  operatorPrivacyStatusUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorPrivacyStatusUpdated
  operatorPrivacyStatusUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorPrivacyStatusUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorPrivacyStatusUpdated_filter
  ): [OperatorPrivacyStatusUpdated!]!
  operatorRemoved(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorRemoved
  operatorRemoveds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorRemoved_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorRemoved_filter
  ): [OperatorRemoved!]!
  operatorWhitelistUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorWhitelistUpdated
  operatorWhitelistUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorWhitelistUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorWhitelistUpdated_filter
  ): [OperatorWhitelistUpdated!]!
  operatorWhitelistingContractUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorWhitelistingContractUpdated
  operatorWhitelistingContractUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorWhitelistingContractUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorWhitelistingContractUpdated_filter
  ): [OperatorWhitelistingContractUpdated!]!
  operatorWithdrawn(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorWithdrawn
  operatorWithdrawns(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorWithdrawn_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorWithdrawn_filter
  ): [OperatorWithdrawn!]!
  operators(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Operator_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Operator_filter
  ): [Operator!]!
  ownershipTransferred(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OwnershipTransferred
  ownershipTransferreds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OwnershipTransferred_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OwnershipTransferred_filter
  ): [OwnershipTransferred!]!
  strategies(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Strategy_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Strategy_filter
  ): [Strategy!]!
  strategy(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Strategy
  strategyBAppOptIn(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StrategyBAppOptIn
  strategyBAppOptIns(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StrategyBAppOptIn_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StrategyBAppOptIn_filter
  ): [StrategyBAppOptIn!]!
  strategyCreated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StrategyCreated
  strategyCreateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StrategyCreated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StrategyCreated_filter
  ): [StrategyCreated!]!
  strategyDeposit(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StrategyDeposit
  strategyDeposits(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StrategyDeposit_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StrategyDeposit_filter
  ): [StrategyDeposit!]!
  strategyFeeUpdateProposed(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StrategyFeeUpdateProposed
  strategyFeeUpdateProposeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StrategyFeeUpdateProposed_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StrategyFeeUpdateProposed_filter
  ): [StrategyFeeUpdateProposed!]!
  strategyFeeUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StrategyFeeUpdated
  strategyFeeUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StrategyFeeUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StrategyFeeUpdated_filter
  ): [StrategyFeeUpdated!]!
  strategyMetadataURIUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StrategyMetadataURIUpdated
  strategyMetadataURIUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StrategyMetadataURIUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StrategyMetadataURIUpdated_filter
  ): [StrategyMetadataURIUpdated!]!
  strategyTokenBalance(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StrategyTokenBalance
  strategyTokenBalances(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StrategyTokenBalance_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StrategyTokenBalance_filter
  ): [StrategyTokenBalance!]!
  strategyUserBalance(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StrategyUserBalance
  strategyUserBalances(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StrategyUserBalance_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StrategyUserBalance_filter
  ): [StrategyUserBalance!]!
  strategyWithdrawal(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StrategyWithdrawal
  strategyWithdrawalProposed(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StrategyWithdrawalProposed
  strategyWithdrawalProposeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StrategyWithdrawalProposed_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StrategyWithdrawalProposed_filter
  ): [StrategyWithdrawalProposed!]!
  strategyWithdrawals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StrategyWithdrawal_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StrategyWithdrawal_filter
  ): [StrategyWithdrawal!]!
  upgraded(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Upgraded
  upgradeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Upgraded_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Upgraded_filter
  ): [Upgraded!]!
  validator(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Validator
  validatorAdded(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ValidatorAdded
  validatorAddeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ValidatorAdded_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ValidatorAdded_filter
  ): [ValidatorAdded!]!
  validatorRemoved(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ValidatorRemoved
  validatorRemoveds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ValidatorRemoved_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ValidatorRemoved_filter
  ): [ValidatorRemoved!]!
  validators(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Validator_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Validator_filter
  ): [Validator!]!
}

"""
A string representation of microseconds UNIX timestamp (16 digits)

"""
scalar Timestamp

type Upgraded {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: Bytes!
  implementation: Bytes!
  transactionHash: Bytes!
}

input Upgraded_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Upgraded_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  implementation: Bytes
  implementation_contains: Bytes
  implementation_gt: Bytes
  implementation_gte: Bytes
  implementation_in: [Bytes!]
  implementation_lt: Bytes
  implementation_lte: Bytes
  implementation_not: Bytes
  implementation_not_contains: Bytes
  implementation_not_in: [Bytes!]
  or: [Upgraded_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum Upgraded_orderBy {
  blockNumber
  blockTimestamp
  id
  implementation
  transactionHash
}

type Validator {
  cluster: Cluster!
  id: Bytes!
  lastUpdateBlockNumber: BigInt!
  lastUpdateBlockTimestamp: BigInt!
  lastUpdateTransactionHash: Bytes!
  operators(first: Int = 100, orderBy: Operator_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Operator_filter): [Operator!]!
  owner: Account!
  removed: Boolean!
  shares: Bytes!
}

type ValidatorAdded {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  cluster_active: Boolean!
  cluster_balance: BigInt!
  cluster_index: BigInt!
  cluster_networkFeeIndex: BigInt!
  cluster_validatorCount: BigInt!
  id: String!
  operatorIds: [BigInt!]!
  owner: Bytes!
  publicKey: Bytes!
  shares: Bytes!
  transactionHash: Bytes!
}

input ValidatorAdded_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ValidatorAdded_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  cluster_active: Boolean
  cluster_active_in: [Boolean!]
  cluster_active_not: Boolean
  cluster_active_not_in: [Boolean!]
  cluster_balance: BigInt
  cluster_balance_gt: BigInt
  cluster_balance_gte: BigInt
  cluster_balance_in: [BigInt!]
  cluster_balance_lt: BigInt
  cluster_balance_lte: BigInt
  cluster_balance_not: BigInt
  cluster_balance_not_in: [BigInt!]
  cluster_index: BigInt
  cluster_index_gt: BigInt
  cluster_index_gte: BigInt
  cluster_index_in: [BigInt!]
  cluster_index_lt: BigInt
  cluster_index_lte: BigInt
  cluster_index_not: BigInt
  cluster_index_not_in: [BigInt!]
  cluster_networkFeeIndex: BigInt
  cluster_networkFeeIndex_gt: BigInt
  cluster_networkFeeIndex_gte: BigInt
  cluster_networkFeeIndex_in: [BigInt!]
  cluster_networkFeeIndex_lt: BigInt
  cluster_networkFeeIndex_lte: BigInt
  cluster_networkFeeIndex_not: BigInt
  cluster_networkFeeIndex_not_in: [BigInt!]
  cluster_validatorCount: BigInt
  cluster_validatorCount_gt: BigInt
  cluster_validatorCount_gte: BigInt
  cluster_validatorCount_in: [BigInt!]
  cluster_validatorCount_lt: BigInt
  cluster_validatorCount_lte: BigInt
  cluster_validatorCount_not: BigInt
  cluster_validatorCount_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorIds: [BigInt!]
  operatorIds_contains: [BigInt!]
  operatorIds_contains_nocase: [BigInt!]
  operatorIds_not: [BigInt!]
  operatorIds_not_contains: [BigInt!]
  operatorIds_not_contains_nocase: [BigInt!]
  or: [ValidatorAdded_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  publicKey: Bytes
  publicKey_contains: Bytes
  publicKey_gt: Bytes
  publicKey_gte: Bytes
  publicKey_in: [Bytes!]
  publicKey_lt: Bytes
  publicKey_lte: Bytes
  publicKey_not: Bytes
  publicKey_not_contains: Bytes
  publicKey_not_in: [Bytes!]
  shares: Bytes
  shares_contains: Bytes
  shares_gt: Bytes
  shares_gte: Bytes
  shares_in: [Bytes!]
  shares_lt: Bytes
  shares_lte: Bytes
  shares_not: Bytes
  shares_not_contains: Bytes
  shares_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum ValidatorAdded_orderBy {
  blockNumber
  blockTimestamp
  cluster_active
  cluster_balance
  cluster_index
  cluster_networkFeeIndex
  cluster_validatorCount
  id
  operatorIds
  owner
  publicKey
  shares
  transactionHash
}

type ValidatorRemoved {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  cluster_active: Boolean!
  cluster_balance: BigInt!
  cluster_index: BigInt!
  cluster_networkFeeIndex: BigInt!
  cluster_validatorCount: BigInt!
  id: String!
  operatorIds: [BigInt!]!
  owner: Bytes!
  publicKey: Bytes!
  transactionHash: Bytes!
}

input ValidatorRemoved_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ValidatorRemoved_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  cluster_active: Boolean
  cluster_active_in: [Boolean!]
  cluster_active_not: Boolean
  cluster_active_not_in: [Boolean!]
  cluster_balance: BigInt
  cluster_balance_gt: BigInt
  cluster_balance_gte: BigInt
  cluster_balance_in: [BigInt!]
  cluster_balance_lt: BigInt
  cluster_balance_lte: BigInt
  cluster_balance_not: BigInt
  cluster_balance_not_in: [BigInt!]
  cluster_index: BigInt
  cluster_index_gt: BigInt
  cluster_index_gte: BigInt
  cluster_index_in: [BigInt!]
  cluster_index_lt: BigInt
  cluster_index_lte: BigInt
  cluster_index_not: BigInt
  cluster_index_not_in: [BigInt!]
  cluster_networkFeeIndex: BigInt
  cluster_networkFeeIndex_gt: BigInt
  cluster_networkFeeIndex_gte: BigInt
  cluster_networkFeeIndex_in: [BigInt!]
  cluster_networkFeeIndex_lt: BigInt
  cluster_networkFeeIndex_lte: BigInt
  cluster_networkFeeIndex_not: BigInt
  cluster_networkFeeIndex_not_in: [BigInt!]
  cluster_validatorCount: BigInt
  cluster_validatorCount_gt: BigInt
  cluster_validatorCount_gte: BigInt
  cluster_validatorCount_in: [BigInt!]
  cluster_validatorCount_lt: BigInt
  cluster_validatorCount_lte: BigInt
  cluster_validatorCount_not: BigInt
  cluster_validatorCount_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorIds: [BigInt!]
  operatorIds_contains: [BigInt!]
  operatorIds_contains_nocase: [BigInt!]
  operatorIds_not: [BigInt!]
  operatorIds_not_contains: [BigInt!]
  operatorIds_not_contains_nocase: [BigInt!]
  or: [ValidatorRemoved_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  publicKey: Bytes
  publicKey_contains: Bytes
  publicKey_gt: Bytes
  publicKey_gte: Bytes
  publicKey_in: [Bytes!]
  publicKey_lt: Bytes
  publicKey_lte: Bytes
  publicKey_not: Bytes
  publicKey_not_contains: Bytes
  publicKey_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum ValidatorRemoved_orderBy {
  blockNumber
  blockTimestamp
  cluster_active
  cluster_balance
  cluster_index
  cluster_networkFeeIndex
  cluster_validatorCount
  id
  operatorIds
  owner
  publicKey
  transactionHash
}

input Validator_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Validator_filter]
  cluster: String
  cluster_: Cluster_filter
  cluster_contains: String
  cluster_contains_nocase: String
  cluster_ends_with: String
  cluster_ends_with_nocase: String
  cluster_gt: String
  cluster_gte: String
  cluster_in: [String!]
  cluster_lt: String
  cluster_lte: String
  cluster_not: String
  cluster_not_contains: String
  cluster_not_contains_nocase: String
  cluster_not_ends_with: String
  cluster_not_ends_with_nocase: String
  cluster_not_in: [String!]
  cluster_not_starts_with: String
  cluster_not_starts_with_nocase: String
  cluster_starts_with: String
  cluster_starts_with_nocase: String
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  lastUpdateBlockNumber: BigInt
  lastUpdateBlockNumber_gt: BigInt
  lastUpdateBlockNumber_gte: BigInt
  lastUpdateBlockNumber_in: [BigInt!]
  lastUpdateBlockNumber_lt: BigInt
  lastUpdateBlockNumber_lte: BigInt
  lastUpdateBlockNumber_not: BigInt
  lastUpdateBlockNumber_not_in: [BigInt!]
  lastUpdateBlockTimestamp: BigInt
  lastUpdateBlockTimestamp_gt: BigInt
  lastUpdateBlockTimestamp_gte: BigInt
  lastUpdateBlockTimestamp_in: [BigInt!]
  lastUpdateBlockTimestamp_lt: BigInt
  lastUpdateBlockTimestamp_lte: BigInt
  lastUpdateBlockTimestamp_not: BigInt
  lastUpdateBlockTimestamp_not_in: [BigInt!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_gt: Bytes
  lastUpdateTransactionHash_gte: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_lt: Bytes
  lastUpdateTransactionHash_lte: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  lastUpdateTransactionHash_not_in: [Bytes!]
  operators: [String!]
  operators_: Operator_filter
  operators_contains: [String!]
  operators_contains_nocase: [String!]
  operators_not: [String!]
  operators_not_contains: [String!]
  operators_not_contains_nocase: [String!]
  or: [Validator_filter]
  owner: String
  owner_: Account_filter
  owner_contains: String
  owner_contains_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_gt: String
  owner_gte: String
  owner_in: [String!]
  owner_lt: String
  owner_lte: String
  owner_not: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_not_in: [String!]
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  removed: Boolean
  removed_in: [Boolean!]
  removed_not: Boolean
  removed_not_in: [Boolean!]
  shares: Bytes
  shares_contains: Bytes
  shares_gt: Bytes
  shares_gte: Bytes
  shares_in: [Bytes!]
  shares_lt: Bytes
  shares_lte: Bytes
  shares_not: Bytes
  shares_not_contains: Bytes
  shares_not_in: [Bytes!]
}

enum Validator_orderBy {
  cluster
  cluster__active
  cluster__balance
  cluster__id
  cluster__index
  cluster__lastUpdateBlockNumber
  cluster__lastUpdateBlockTimestamp
  cluster__lastUpdateTransactionHash
  cluster__networkFeeIndex
  cluster__validatorCount
  id
  lastUpdateBlockNumber
  lastUpdateBlockTimestamp
  lastUpdateTransactionHash
  operators
  owner
  owner__feeRecipient
  owner__id
  owner__metadataURI
  owner__nonce
  owner__totalDelegatedPercentage
  owner__validatorCount
  removed
  shares
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
  """The hash of the parent block"""
  parentHash: Bytes
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}